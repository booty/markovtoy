C is a general-purpose programming language which features economy of expression, modern control flow and data structures, and a rich set of operators. C is not a “very high level” language, nor a “big” one, and is not specialized to any particular area of application. But its absence of restrictions and its generality make it more convenient and effective for many tasks than supposedly more powerful languages.
C was originally designed for and implemented on the UNIXt operating system on the DEC PDP-11, by Dennis Ritchie. The operating system, the C compiler, and essentially all UNIX applications programs (including all of the software used to prepare this book) are written in C. Production compilers also exist for several other machines, including the IBM System/370, the Honeywell 6000, and the Interdata 8/32. C is not tied to any particular hardware or system, however, and it is easy to write programs that will run without change on any machine that supports C.
This book is meant to help the reader (earn how to program in C. It contains a tutorial introduction to get new users started as soon as possible, separate chapters on each major feature, and a reference manual. Most of the treatment is based on reading, writing and revising examples, rather than on mere statements of rules. For the most part, the examples are complete, real programs, rather than isolated fragments. All examples have been tested directly from the text, which is in machine-readable form. Besides showing how to make effective use of the language, we have also tried where possible to illustrate useful algorithms and principles of good style and sound design.
The book is not an introductory programming manual; it assumes some familiarity with basic programming concepts like variables, assignment statements, loops, and functions. Nonetheless, a novice programmer should be able to read along and pick up the language, although access to a more knowledgeable colleague will help.
In our experience, C has proven to be a pleasant, expressive, and versatile language for a wide variety of programs. It is easy to learn, and it wears well as one’s experience with it grows. We hope that this book will help you to use it well.
The thoughtful criticisms and suggestions of many friends and colleagues have added greatly to this book and to our pleasure in writing it. In particular, Mike Bianchi, Jim Blue, Stu Feldman, Doug Mcllroy, Bill Roome, Bob Rosin, and Larry Rosier all read multiple versions with care. We are also indebted to A1 Aho, Steve Bourne, Dan Dvorak, Chuck Haley, Debbie Haley, Marion Harris, Rick Holt, Steve Johnson, John Mashey, Bob Mitze, Ralph Muha, Peter Nelson, Elliot Pinson, Bill Plauger, Jerry Spivack, Ken Thompson, and Peter Weinberger for helpful comments at various stages, and to Mike Lesk and Joe Ossanna for invaluable assistance with typesetting.
C is a general-purpose programming language. It has been closely associated with the UNIX system, since it was developed on that system, and since UNIX and its software are written in C. The language, however, is not tied to any one operating system or machine; and although it has been called a “system programming language” because it is useful for writing operating systems, it has been used equally well to write major numerical, textprocessing, and data-base programs.
C is a relatively “low level” la nguage. This characterization is not pejorative; it simply means that C deals with the same sort of objects th at mo st combuters do . namely charac ters, numbers, and addresses. These may be combined and moved about with the usual aritnmetiCTtmf logical operators implemented by actual machines.
Similarly, C offers only straightforward, single-thread control flow constructions: tests, loops, grouping, and sub programs, but not multiprogramming, parallel operations, synchronization, or coroutines.
Again because the language reflects the capabilities of current computers, C programs tend to be efficient enough that there is no compulsion to write assembly language instead. The most obvious example of this is the UNIX operating system itself, which is written almost entirely in C. Of 13000 lines of system code, only about 800 lines at the very lowest level are in assembler. In addition, essentially all of UNIX applications software is written in C; the vast majority of UNIX users (including one of the authors of this book) do not even know the PDP-11 assembly language.
Although C matches the capabilities of many computers, it is independent of any particular machine architecture, and so with a little care it is easy to write “portable” programs, that is, programs which can be run without change on a variety of hardware. It is now routine in our environment that software developed on UNIX is transported to the local Honeywell, IBM and Interdata systems. In fact, the C compilers and runtime support on these four machines are much more compatible than the supposedly ANSI standard versions of Fortran. The UNIX operating system itself now runs on both the PDP-11 and the Interdata 8/32. Outside of programs which are necessarily somewhat machine-dependent like the compiler, assembler, and debugger, the software written in C is identical on both machines. Within the operating system itself, the 7000 lines of code outside percent identical.
For programmers familiar with other languages, it may prove helpful to mention a few historical, technical, and philosophical aspects of C, for contrast and comparison.
Many of the most important ideas of C stem from the considerable older, but still quite vital, language BCPL, developed by Martin Richards The influence of BCPL on C proceeded indirectly through the language B. which was written by Ken Thompson in 1970 for the first UNIX system on the PDP-7.
Although it shares several characteristic features with BCPL, C is in no sense a dialect of it. BCPL and B are “typeless” languages: the only data type is the machine word, and access to other kinds of objects is by special operators or function calls. In C, the fun damenta l data obje ct s a re chara cters, integers of several sizes, and floating poi nt num bers. In addition, there is a hierarchy of deri ved data types cr eated with pointers, arrays, structures . junions % and functions.
C provides pointers and the ability to do address arit hmetic . The arguments to functions are passed by copying the value of the argument, and it is impossible for the called function to change the actual argument in the caller. When it is desired to achieve “call by reference,” a pointer may be passed explicitly, and the function may change the object to which the pointer points. Array names are passed as the location of the array origin, so array arguments are effectively call by reference.
Any function may be called recursively, and its local variables are typically “automatic,” or created anew with each invocation. Function definitions may not be nested but variables may be declared in a blockstructured fashion. The functions of a C program may be compiled separately. Variables may be internal to a function, external but known only within a single source file, or completely global. Internal variables may be automatic or static. Automatic variables may be placed in registers for increased efficiency, but the register declaration is only a hint to the compiler, and does not refer to specific machine registers.
C is not a strongly-typed language in the sense of Pascal or Algol 68. It is relativel y permissive about data conversi on, although it will not automatically convert data types with the wild abandon of PL/I. Existing compi lers p rovide no run-time checking of array s u bscripts, argume nt types, etc.
For those situations where strong type checking is desirable, a separate version of the compiler is used. This program is called lint, apparently because it picks bits of fluff from one’s programs, lint does hot generate code, but instead applies a very strict check to as many aspects of a program as can be verified at compile and load time. It detects type mismatches. incon si stent argument usage, unused or apparently uninitial ized variables. p oten t ial portability difficulties, and the like. Programs which pass unscathed through lint enjoy, with few exceptions, freedom from type errors about as complete as do, for example, Algol 68 programs. We will mention other lint capabilities as the occasion arises.
Finally, C, like any other language, has its blemishes. Some of the operators have the wrong precedence; some parts of the syntax could be better; there are several versions of the language extant, differing in minor ways. Nonetheless, C has proven to be an extremely effective and expressive language for a wide variety of programming applications.
The rest of the book is organized as follows. Chapter 1 is a tutorial introduction to the central part of C. The purpose is to get the reader started as quickly as possible, since we believe strongly that the only way to learn a new language is to write programs in it. The tutorial does assume a working knowledge of the basic elements of programming; there is no explanation of computers, of compilation, nor of the meaning of an expression like n=n+1 . Although we have tried where possible to show useful programming techniques, the book is not intended to be a reference work on data structures and algorithms; when forced to a choice, we have concentrated on the language rather more formally, than does Chapter 1, although the emphasis is still on examples of complete, useful programs, rather than isolated fragments. ers functions and program structure — external variables, scope rules, and so on. Chapter 5 discusses pointers and address arithmetic. Chapter 6 contains the details of structures and unions. mon interface to the operating system. This I/O library is supported on all machines that support C, so programs which use it for input, output, and other system functions can be moved from one system to another essentially without change. operating system, concentrating on input/output, the file system, and portability. Although some of this chapter is UNIX-specific, programmers who are not using a UNIX system should still find useful material here, including some insight into how one version of the standard library is implemented, and suggestions on achieving portable code.
Since C is an evolving language that exists on a variety of systems, some of the material in this book may not correspond to the current state of development for a particular system. We have tried to steer clear of such problems, and to warn of potential difficulties. When in doubt, however, we have generally chosen to describe the PDP-11 UNIX situation, since that is the environment of the majority of C programmers. Appendix A also describes implementation differences on the major C systems.
Let us begin with a quick introduction to C. Our aim is to show the essential elements of the language in real programs, but without getting bogged down in details, formal rules, and exceptions. At this point, we are not trying to be complete or even precise (save that the examples are meant to be correct). We want to get you as quickly as possible to the point where you can write useful programs, and to do that we have to concentrate on the basics: variables and constants, arithmetic, control flow, functions, and the rudiments of input and output. We are quite intentionally leaving out of this chapter features of C which are of vital importance for writing bigger programs. These include pointers, structures, most of C’s rich set of operators, several control flow statements, and myriad details.
This approach has its drawbacks, of course. Most notable is that the complete story on any particular language feature is not found in a single place, and the tutorial, by being brief, may also mislead. And because they can not use the full power of C, the examples are not as concise and elegant as they might be. We have tried to minimize these effects, but be warned.
Another drawback is that later chapters will necessarily repeat some of this chapter. We hope that the repetition will help you more than it annoys.
In any case, experienced programmers should be able to extrapolatefrom the material in this chapter to their own programming needs. Beginners should supplement it by writing small, similar programs of their own. Both groups can use it as a framework on which to hang the more detailed descriptions that begin in Chapter 2.
This is the basic hurdle; to leap over it you have to be able to create the program text somewhere, compile it successfully, load it, run it, and find out where your output went. With these mechanical details mastered, everything else is comparatively easy.
If you haven’t botched anything, such as omitting a character or misspelling something, the compilation will proceed silently, and make an executable file. On other systems, the rules will be different; check with a local expert.
Run this program on your system. Experiment with leaving out parts of the program, to see what error messages you get.
Now for some explanations about the program itself. A C program, whatever its size, consists of one or more “functions” which specify the actual computing operations that are to be done. C functions are similar to the functions and subroutines of a Fortran program or the procedures of PL/I, Pascal, etc. In our example, main is such a function. Normally you are at liberty to give functions whatever names you like, but main is a special name — your program begins executing at the beginning of main. This means that every program must have a main somewhere, main will usually invoke other functions to perform its job, some coming from the same program, and others from libraries of previously written functions.
One method of communicating data between functions is by arguments. The parentheses following the function name surround the argument list; here main is a function of no arguments, indicated by ( ) . The braces { } enclose the statements that make up the function; they are analogous to the DO-END of PL/I, or the begin-end of Algol, Pascal, and so on. A function is invoked by naming it, followed by a parenthesized list of arguments. There is no CALL statement as there is in Fortran or PL/I. The parentheses must be present even if there are no arguments. The line that says is a function call, which calls a function named printf, with the argument "hello, world\n". printf is a library function which prints output on the terminal (unless some other destination is specified). In this case it prints the string of characters that make up its argument.
A sequence of any number of characters enclosed in the double quotes "... " is called a character string or string constant For the moment our only use of character strings will be as arguments for printf and other functions.
Notice that ,\n represents only a single character. An escape sequence like \n provides a general and extensible mechanism for representing hardto-get or invisible characters. Among the others that C provides are \t for tab, \b for backspace, \" for the double quote, and \\ for the backslash itself.
Experiment to find out what happens when printf ’s argument string contains \x, where x is some character not listed above.
In C, all variables must be( declared before use, usually at the beginning of the function before any ex^butable statements. If you forget a declaration, you will get a diagnostic from the compiler.
The type int implies that the variables listed are integers ; float stands for floating point, i.e., numbers which may have a fractional part. The precision of both int and float depends on the particular machine you are using. On the PDP-11, for instance, an int is a 16-bit signed number, that is, one which lies between -32768 and +32767. A float number is a 32-bit quantity, which amounts to about seven significant digits, with magnitude between about 10 -38 and 10 +38 . Chapter 2 lists sizes for other machines.
The sizes of these objects are also machine-dependent; details are in Chapter 2. There are also arrays , structures and unions ,of these basic types, pointers to them, and functions that return them, all of which we will meet in due course.
The condition in parentheses is tested. If it is true (fahr is less than or equal to upper), the body of the loop (all of the statements enclosed by the braces { and }) is executed. Then the condition is re-tested, and if true, the body is executed again. When the test becomes false (fahr exceeds upper) the loop ends, and execution continues at the statement that follows the loop. There are no further statements in this program, so it terminates.
In either case, the statements controlled by the while are indented by one tab stop so you can see at a glance what statements are inside the loop. The indentation emphasizes the logical structure of the program. Although C is quite permissive about statement positioning, proper indentation and use of white space are critical in making programs easy for people to read. We recommend writing only one statement per line, and (usually) leaving blanks around operators. The position of braces is less important; we have chosen one of several popular styles. Pick a style that suits you, then use it consistently.
The reason for using 5. 0/9.0 instead of the simpler looking 5/9 is that in C, as in many other languages, integer division truncates , so any fractional part is discarded. Thus 5/9 is zero and of course so would be all the temperatures. A decimal point in a constant indicates that it is floating point, so 5. 0/9.0 is 0.555... , which is what we want.
We also wrote 32.0 instead of 32, even though since fahr is a float, 32 would be automatically converted to f loat (to 32.0) before the subtraction. As a matter of style, it’s wise to write floating point constants with explicit decimal points even when they have integral values; it emphasizes their floating point nature for human readers, and ensures that the compiler will see things your way too.
Each % construction in the first argument of printf is paired with its corresponding second, third, etc., argument; they must line up properly by number and type, or you’ll get meaningless answers.
By the way, printf is not part of the C language; there is no input or output defined in C itself. There is nothing magic about printf; it is just a useful function which is part of the standard library of routines that are normally accessible to C programs. In order to concentrate on C itself, we won’t talk much about I/O until Chapter 7. In particular, we will defer formatted input until then. If you have to input numbers, read the discussion of the function scanf in Chapter 7, section 7.4. scanf is much like printf, except that it reads input instead of writing output.
This produces the same answers, but it certainly looks different. One major change is the elimination of most of the variables; only fahr remains, as an int (to show the %d conversion in printf). The lower and upper limits and the step size appear only as constants in the for statement, itself a new construction, and the expression that computes the Celsius temperature now appears as the third argument of printf instead of in a separate assignment statement.
The choice between while and for is arbitrary, based on what seems clearer. The for is usually appropriate for loops in which the initialization and re-initialization are single statements and logically related, since it is more compact than while and keeps the loop control statements together in one place.
Modify the temperature conversion program to print the table in reverse order, that is, from 300 degrees to 0.
A final observation before we leave temperature conversion forever. It’s bad practice to bury “magic numbers” like 300 and 20 in a program; they convey little information to someone who might have to read the program later, and they are hard to change in a systematic way. Fortunately, C provides a way to avoid such magic numbers. With the #define construction, at the beginning of a program you can define a symbolic name or symbolic constant to be a particular string of characters. Thereafter, the compiler will replace all unquoted occurrences of the name by the corresponding string. The replacement for the name can actually be any text at all; it is not limited to numbers.
The quantities LOWER, UPPER and STEP are constants, so they do not appear in declarations. Symbolic names are commonly written in upper case so they can be readily distinguished from lower case variable names. Notice that there is no semicolon at the end of a definition. Since the whole line after the defined name is substituted, there would be too many semicolons in the for.
We are now going to consider a family of related programs for doing simple operations on character data. You will find that many programs are just expanded versions of the prototypes that we discuss here.
The standard library provides functions for reading and writing a character at a time. getcharO fetches the next input character each time it is called, and returns that character as its value. That is, after c contains the next character of input. The characters normally come from the terminal, but that need not concern us until Chapter 7.
Given getchar and putchar, you can write a surprising amount of useful code without knowing anything more about I/O. The simplest example is a program which copies its input to its output one character at a time.
The main problem is detecting the end of the input. By convention, getchar returns a value which is not a valid character when it encounters the end of the input; in this way, programs can detect when they run out of input. The only complication, a serious nuisance, is that there are two conventions in common use about what that end of file value really is. We have deferred the issue by using the symbolic name EOF for the value, whatever it might be. In practice, EOF will be either -1 or 0, so the program must be preceded by the appropriate one of in order to work properly. By using the symbolic constant EOF to represent the value that getchar returns when end of file occurs, we are assured that only one thing in the program depends on the specific numeric value.
We also declare c to be an int, not a char, so it can hold the value which getchar returns. As we shall see in Chapter 2, this value is actually an int, since it must be capable of representing EOF in addition to all possible char’s.
The program for copying would actually be written more concisely by experienced C programmers. In C, any assignment can be used in an expression; its value is simply the value being assigned to the left hand side. If the assignment of a character to c is put inside the test part of a while, the file copy program can be written. The program gets a character, assigns it to c, and then tests whether the character was the end of file signal. If it was not, the body of the while is executed, printing the character. The while then repeats. When the end of the input is finally reached, the while terminates and so does inain.
It’s important to recognize that the parentheses around the assignment within the conditional are really necessary. The precedence of ! = is higher than that of =, which means that in the absence of parentheses the relational test ! = would be done before the assignment.
The next program counts characters; it is a small elaboration of the copy program.
The statement shows a new operator, ++, which means increment by one. You could write nc = nc + 1 but ++nc is more concise and often more efficient. There is a corresponding operator — to decrement by 1 . The operators ++ and — can be either prefix operators (++nc) or postfix (nc++); these two forms have different values in expressions, as will be shown in Chapter 2, but ++nc and nc++ both increment nc. For the moment we will stick to prefix.
The character counting program accumulates its cou^t in a long variable instead of an int. On a PDP-11 the maximum value of an int is 32767, and it would take relatively little input to overflow the counter if it were declared int; in Honeywell and IBM C, long and int are synonymous and much larger. The conversion specification %ld signals to printf that the corresponding argument is a long integer.
To cope with even bigger numbers, you can use a double (double length float). We will also use a for statement instead of a while, to illustrate an alternative way to write the loop.
The body of the for loop here is empty , because all of the work is done in the test and re-initialization parts. But the grammatical rules of C require that a for statement have a body. The isolated semicolon, technically a null statement , is there to satisfy that requirement. We put it on a separate line to make it more visible.
Before we leave the character counting program, observe that if the input contains no characters, the while or for test fails on the very first call to getchar, and so the program produces zero, the right answer. This is an important observation. One of the nice things about while and for is that they test at the top of the loop, before proceeding with the body. If there is nothing to do, nothing is done, even if that means never going through the loop body. Programs should act intelligently when handed input like “no characters.” The while and for statements help ensure that they do reasonable things with boundary conditions.
The body of the while now consists of an if, which in turn controls the increment ++nl. The if statement tests the parenthesized condition, and if it is true, does the statement (or group of statements in braces) that follows. We have again indented to show what is controlled by what.
The double equals sign == is the C notation for “is equal to” (like Fortran’s .EQ.). This symbol is used to distinguish the equality test from the single = used for assignment. Since assignment is about twice as frequent as equality testing in typical C programs, it’s appropriate that the operator be half as long.
Any single character can be written between single quotes, to produce a value equal to the numerical value of the character in the machine’s character set; this is called a character constant. So, for example, 'A' is a character constant; in the ASCII character set its value is 65, the internal representation of the character A. Of course 'A' is to be preferred over 65: its meaning is obvious, and it is independent of a particular character set.
There is a corresponding operator && for AND. Expressions connected by && or | | are evaluated left to right, and it is guaranteed that evaluation will stop as soon as the truth or falsehood is known. Thus if c contains a blank, there is no need to test whether it contains a newline or tab, so these tests are not made. This isn’t particularly important here, but is very significant in more complicated situations, as we will soon see.
One and only one of the two statements associated with an if-else is done. If the expression is true, statement-1 is executed; if not, statement-2 is executed. Each statement can in fact be quite complicated. In the word count program, the one after the else is an if that controls two statements in braces.
By definition, arithmetic involving char’s and int’s converts everything to int before proceeding, so char variables and constants are essentially identical to int’s in arithmetic contexts. This is quite natural and convenient; for example, c - ' 0 ' is an integer expression with a value between 0 and 9 corresponding to the character ' 0 ' to ' 9 ' stored in c, and is thus a valid subscript for the array ndigit.
The switch statement, to be discussed in Chapter 3, provides another way to write a multi-way branch that is particularly suitable when the condition being tested is simply whether some integer oi^charact^^pi^sipn' matches one of a set of constants. For contrast^ we wilf present a switch version of this program in Chapter 3.
Write a program to print a histogram of the lengths of words in its input. It is easiest to draw the histogram horizontally; a vertical orientation is more challenging.
In C, a function is equivalent to a subroutine or function in Fortran, or a procedure in PL/I, Pascal, etc. A function provides a convenient way to encapsulate some computation in a black box, which can then be used without worrying about its innards. Functions are really the only way to cope with the potential complexity of large programs. With properly designed functions, it is possible to ignore how a job is done; knowing what is done is sufficient. C is designed to make the use of functions easy, convenient and efficient; you will often see a function only a few lines long called only once, just because it clarifies some piece of code.
So far we have used only functions like printf, getchar and putchar that have been provided for us; now it’s time to write a few of our own. Since C has no exponentiation operator like the ** of Fortran or PL/I, let us illustrate the mechanics of function definition by writing a function power (m, n) to raise an integer m to a ^positive integer power n. That is, the value of power (2, 5) is 32. This function certainly doesn’t do the whole job of ** since it handles only positive powers of small integers, but it’s best to confuse only one issue at a time.
The functions can appear in either order, and in one source file or in two. Of course if the source appears in two files, you will have to say more to compile and load it than if it all appears in one, but that is an operating system matter, not a language attribute. For the moment, we will assume that both functions are in the same file, so whatever you have learned about running C programs will not change.
The function power is called twice in the line that follows the function name. The argument declarations go between the argument list and the opening left brace; each declaration is terminated by a semicolon. The names used by power f or its arg uments are purely local to powe r, and not accessible to any other function: other routine s can use the same names without conflict. This is also true of the variables” i and p: the i in power is unrelated to the i in main.
The value that power computes is returned to main by the return statement, which is just as in PL/I. Any expression may occur within the parentheses. A function need not return a value; a return statement with no expression causes control, but no useful value, to be returned to the caller, as does “falling off the end” of a function by reaching the terminating right brace.
One aspect of C functions may be unfamiliar to programmers who are used to other languages, particularly Fortran and P^/I. In C, all function arguments are passed “by value.” This means that the called functio n^ js given the values of its arguments in temporary variables (actually on a stack) rather than their addresses. This leads to some different properties than are seen with “call by reference” languages like Fortran and PL/I, in which the called routine is handed the address of the argument, not its value.
The main distinction is that in C the called function carmqi alter a variable in the calling function; it can only a lter its private, temporary copy .
Caff by value is an asset, however, not a liability. It usually leads to more compact programs with fewer extraneous variables, because arguments can be treated as conveniently initialized local variables in the called routine. For example, here is a version of power which makes use of this fact.
The argument i n 'js used as a temporary variable, and is counted down until it becomes zero; there is no longer a need for the variable i. Whatever is done to n inside power has no effect on the argument that power was originally called with.
When necessary, it is possible to arrange for a f unction to modify a variable in a calling routine. The caller must provide the address of the variable to be set (technically a pointer to the variable) , a nd the called function must declare the argument to be a pointer and reference the actual variable indire ctly through it. We will cover this in detail in Chapter 5.
When the na me of a n array is used as an argument, the value passed to the function is actually the location or address of the beginning of the array. (There is «o copying of array elements.) By subscripting this value, the function can access and alter any eleme nt o f the array. This is the topic of the next section.
This outline makes it clear that the program divides naturally into pieces. One piece gets a new line, another tests it, another saves it, and the rest controls the process.
Since things divide so nicely, it would be well to write them that way too. Accordingly, let us first write a separate function get line to fetch the next line o f input; this is a generalization of getchar . To make The~ function useful in other contexts, we’ll try to make it as flexible as possible. At the minimum, getline has to return a signal about possible end ofjile^a^ more generally useful design would be to return the length of the line, or zero if e nd of fil e is e ncountered. Zero is never a valid line length since every line has _at least one character; even a line containing only a newline has le ngt h 1.
When we find a line that is longer than the previous longest, it must be saved somewhere. This suggests a second function, copy, to copy the new line to a safe place.
It is worth mentioning in passing that even a program as small as this one presents some sticky design problems. For example, what should main do if it encounters a line which is bigger than its limit? getline works properly, in that it stops collecting when the array is full, even if no newline ha s be en seen. By testing the length and the last character returned, main can determine whether the line was too long, and then cope as it wishes. In the interests of brevity, we have ignored the issue.
There is no way for a user of getline to know in advance how long an input line might be, so getline checks for overflow. On the other hand, the user of copy already knows (or can find out) how big the strings are, so we have chosen not to add error checking to it.
Revise the main routine of the longest-line program so it will correctly print the length of arbitrarily long input lines, and as much as possible of the text.
The external variables in main, getline and copy are defined by the first lines of the example above, which state their type and cause storage to be allocated for them. Syntactically, external definitions are just like the declarations we have used previously, but since they occur outside of functions, the variables are external. Before a function can use an external variable, the name of the variable must be made known to the function. One way to do this is to write an extern declaration in the function; the declaration is the same as before except for the added keyword extern.
In certain circumstances, the extern declaration can be omitted: if the external definition of a variable occurs in the source file before its use in a particular function, then there is no need for an extern declaration in the function. The extern declarations in main, getline and copy are thus redundant. In fact, common practice is to place definitions of all external variables at the beginning of the source file, and then omit all extern declarations.
If the program is on several source files, and a variable is defined in, say, filel and used in file2, then an extern declaration is needed in file2 to connect the two occurrences of the variable. This topic is discussed at length in Chapter 4.
You should note that we are using the words declaration and definition carefully when we refer to external variables in this section. “Definition” refers to the place where the variable is actually created or assigned storage; “declaration” refers to places where the nature of the variable is stated but no storage is allocated.
By the way, there is a tendency to make everything in sight an extern variable because it appears to simplify communications — argument lists are short and variables are always there when you want them. But external variables are always there even when you don’t want them. This style of coding is fraught with peril since it leads to programs whose data connections are not at all obvious — variables can be changed in unexpected and even inadvertent ways, and the program is hard to modify if it becomes necessary. The second version of the longest-line program is inferior to the first, partly for these reasons, and partly because it destroys the generality of two quite useful functions by wiring into them the names of the variables they will manipulate.
At this point we have covered what might be called the conventional core of C. With this handful of building blocks, it’s possible to write useful programs of considerable size, and it would probably be a good idea if you paused long enough to do so. The exercises that follow are intended to give you suggestions for programs of somewhat greater complexity than the ones presented in this chapter.
After you have this much of C under control, it will be well worth your effort to read on, for the features covered in the next few chapters are where the power and expressiveness of the language begin to become apparent.
Variables and constants are the basic data objects manipulated in a program. Declarations list the variables to be used, and state what type they have and perhaps what their initial values are. Operators specify what is to be done to them. Expressions combine variables and constants to produce new values. These are the topics of this chapter.
Although we didn’t come right out and say so, there are some restrictions on variable and symbolic constant names. Names are made up of letters and digits; the first character must be a letter. The underscore counts as a letter; it is useful for improving the readability of long variable names. Upper and lower case are different; traditional C practice is to use lower case for variable names, and all upper case for symbolic constants.
Naturally it’s wise to choose variable names that mean something, that are related to the purpose of the variable, and that are unlikely to get mixed up typographically.
The intent is that short and long should provide different lengths of integers where practical; int will normally reflect the most “natural” size for a particular machine. As you can see, each compiler is free to interpret short and long as appropriate for its own hardware. About all you should count on is that short is no longer than long.
A character constant is a single character written within single quotes, as in ' x ' . The value of a character constant is the numeric value of the character in the machine’s character set. For example, in the ASCII character set the character zero, or 'O', is 48, and in EBCDIC ' 0 ' is 240, both quite different from the numeric value 0. Writing ' 0 ' instead of a numeric value like 48 or 240 makes the program independent of the particular value.
The character constant '\0' represents the character with value zero. '\0' is often written instead of 0 to emphasize the character nature of some expression.
The quotes are not part of the string, but serve only to delimit it. The same escape sequences used for character constants apply in strings; \" represents the double quote character.
Technically, a string is an array whose elements are single characters. The compiler automatically places the null character \0 at the end of each such string, so programs can conveniently find the end. This representation means that there is no real limit to how long a string can be, but programs have to scan one completely to determine its length. The physical storage required is one more location than the number of characters written between the quotes. The following function strlen(s) returns the length of a character string s, excluding the terminal \0.
Be careful to distinguish between a character constant and a string that contains a single character: 'x' is not the same as "x". The former is a single character, used to produce the numeric value of the letter x in the machine’s character set. The latter is a character string that contains one character (the letter x) and a \0.
If the variable in question is external or static, the initialization is done once only, conceptually before the program starts executing. Explicitly initialized automatic variables are initialized each time the function they are in is called. Automatic variables for which there is no explicit initializer have undefined (i.e., garbage) values. External and static variables are initialized to zero by default, but it is good style to state the initialization anyway.
The + and - operators have the same precedence, which is lower than the (identical) precedence of *, /, and %, which are in turn lower than unary minus. Arith metic operators group left to righ t. (A table at the end of this chapter summarizes precedence and associativity for all operators.) The order of evaluation is not specified for associative and commutative operators like * and +; the compiler may rearrange a parenthesized computation involving one of these.
More interesting are the logical connectives && and I I . Expressions connected by && or M are evalu ated-lefLio right, and evaluatiorTitops as "soon afthe truth or laisehood of the result is known. These properties are critical to writing programs that work. For example, here is a loop from the input function getline which we wrote in Chapter 1.
Clearly, before reading a new character it is necessary to check that there is room to store it in the array s, so the test i<lim-1 must be made first. Not only that, but if this test fails, we must not go on and read another character.
Similarly, it would be unfortunate if c were tested against EOF before getchar was called: the call must occur before the character in c is tested.
When operands of different types appear in expressions, they are converted to a common type according to a small number of rules. In general, the only conversions that happen automatically are those that make sense, such as converting an integer to floating point in an expression like f + i. Expressions that don’t make sense, like using a float as a subscript, are disallowed.
This works for ASCII because corresponding upper case and lower case letters are a fixed distance apart as numeric values and each alphabet is contiguous — there is nothing but letters between A and Z. This latter observation is not true of the EBCDIC character set (IBM 360/370), so this code fails on such systems — it converts more than letters.
There is one subtle point about the conversion of characters to integers. The language does not specify whether variables of type char are signed or unsigned quantities. When a char is converted to an int, can it ever produce a negative integer? Unfortunately, this varies from machine to machine, reflecting differences in architecture. On some machines (PDP-11, for instance) , a char whose leftmost bit is 1 will be converted to a negative integer (“sign extension”). On others, a char is promoted to an int by adding zeros at the left end, and thus is always positive.
The definition of C guarantees that any character in the machine’s standard character set will never be negative, so these characters may be used freely in expressions as positive quantities. But arbitrary bit patterns stored in character variables may appear to be negative on some machines, yet positive on others.
On a machine which does not do sign extension, c is always positive because it is a char, yet EOF is negative. As a result, the test always fails. To avoid this, we have been careful to use int instead of char for any variable which holds a value returned by getchar.
The real reason for using int instead of char is not related to any questions of possible sign extension. It is simply that getchar must return all possible characters (so that it can be used to read arbitrary input) and, in addition, a distinct EOF value. Thus its value cannot be represented as a char, but must instead be stored as an int.
Implicit arithmetic conversions work much as expected. In general, if an operator like + or * which takes two operands (a “binary operator”) has operands of different types, the “lower” type is promoted to the “higher” type before the operation proceeds. The result is of the higher type. More precisely, for each arithmetic operator, the following sequence of conversion rules is applied.
Then if either operand is double, the other is converted to double, and the result is double.
Otherwise if either operand is long, the other is converted to long, and the result is long.
Otherwise if either operand is unsigned, the other is converted to unsigned, and the result is unsigned.
Notice that all float’s in an expression are converted to double; all floating point arithmetic in C is done in double precision.
Since a function argument is an expression, type conversions also take place when arguments are passed to functions: in particular, char and short become int, and float becomes double. This is why we have declared function arguments to be int and double even when the function is called with char and float.
Write the function htoi(s), which converts a string of hexadecimal digits into its equivalent integer value. The allowable digits are 0 through 9, a through f , and A through F.
As a third example, the function strcat (s, t) concatenates the string t to the end of the string s. strcat assumes that there is enough space in s to hold the combination.
As each character is copied from t to s, the postfix ++ is applied to both i and j to make sure that they are in position for the next pass through the loop.
Write an alternate version of squeeze (si, s2) which deletes each character in si which matches any character in the string s2.
Write the function any (si, s2) which returns the first location in the string si where any character from the string s2 occurs, or -1 if si contains no characters from s2.
C provides a number of operators for bit manipulation; these may not be applied to float or double.
The shift operators « and » perform left and right shifts of their left operand by the number of bit positions given by the right operand. Thus x « 2 shifts x left by two positions, filling vacated bits with 0; this is equivalent to multiplication by 4. Right shifting an unsigned quantity fills vacated bits with 0. Right shifting a signed quantity will fill with sign bits (“arithmetic shift”) on some machines such as the PDP-11, and with 0-bits (“logical shift”) on others.
To illustrate the use of some of the bit operators, consider the function getbits(x, p, n) which returns (right adjusted) the n-bit field of x that begins at position p. We assume that bit position 0 is at the right end and that n and p are sensible positive values. For example, ge tbits (x, 4, 3 ) returns the three bits in bit positions 4, 3 and 2, right adjusted.
Write a function wordlength ( ) which computes the word length of the host machine, that is, the number of bits in an int. The function should be portable, in the sense that the same source code works on all machines.
Write the function right rot (n, b) which rotates the integer n to the right by b bit positions.
Write the function invert (x, p, n) which inverts (i.e., changes 1 into 0 and vice versa) the n bits of x that begin at position p, leaving the others unchanged.
As an example, the function bitcount counts the number of 1-bits in its integer argument.
Assignments using the other assignment operators (+=, -=, etc.) can also occur in expressions, although it is a less frequent occurrence.
In a 2’s complement number system, x & (x-1 ) deletes the rightmost 1-bit in x. (Why?) Use this observation to write a faster version of bitcount.
Parentheses are not necessary around the first expression of a conditional expression, since the precedence of ? : is very low, just above assignment. They are advisable anyway, however, since they make the condition part of the expression easier to see.
The conditional expression often leads to succinct code. For example, this loop prints N elements of an array, 10 per line, with each column separated by one blank, and with each line (including the last) terminated by exactly one newline.
A newline is printed after every tenth element, and after the N-th. All other elements are followed by one blank. Although this might look tricky, it’s instructive to try to write it without the conditional expression.
Rewrite the function lower, which converts upper case letters to lower case, with a conditional expression instead of if-else.
The table below summarizes the rules for precedence and associativity of all operators, including those which we have not yet discussed. Operators on the same line have the same precedence; rows are in order of decreasing precedence, so, for example, *, /, and % all have the same precedence, which is higher than that of + and -.
The operators -> and . are used to access members of structures; they will discusses * (indirection) and & (address of).
As mentioned before, expressions involving one of the associative and commutative operators (*, +, &, l) can be rearranged even when parenthesized. In most cases this makes no difference whatsoever; in situations where it might, explicit temporary variables can be used to force a particular order of evaluation.
The question is whether the subscript is the old value of i or the new. The compiler can do this in different ways, and generate different answers depending on its interpretation. When side effects (assignment to actual variables) takes place is left to the discretion of the compiler, since the best order strongly depends on machine architecture.
The control flow statements of a language specify the order in which computations are done. We have already met the most common control flow constructions of C in earlier examples; here we will complete the set, and be more precise about the ones discussed before.
In C, the semicolon is a statement terminator, rather than a separator as it is in Algol-like languages.
The braces { and } are used to group declarations and statements together into a compound statement or block so that they are syntactically equivalent to a single statement. The braces that surround the statements of a function are one obvious example; braces around multiple statements after an if, else, while or for are another. (Variables can actually be declared inside any block; we will talk about this in Chapter 4.) There is never a semicolon after the right brace that ends a block.
The indentation shows unequivocally what you want, but the compiler doesn’t get the message, and associates the else with the inner if. This kind of bug can be very hard to find.
This is because grammatically, a statement follows the if, and an expression statement like z = a is always terminated by a semicolon.
To illustrate a three-way decision, here is a binary search function that decides if a particular value x occurs in the sorted array v. The elements of v must be in increasing order. The function returns the position (a number between 0 and n-1 ) if x occurs in v, and -1 if not.
The fundamental decision is whether x is less than, greater than, or equal to the middle element v[mid] at each step; this is a natural for else-if.
The switch statement is a special multi-way decision maker that tests whether an expression matches one of a number of constant values, and branches accordingly. In Chapter 1 we wrote a program to count the occurrences of each digit, white space, and all other characters, using a sequence of if ... else if ... else. Here is the same program with a switch.
The switch evaluates the integer expression in parentheses (in this program the character c) and compares its value to all the cases. Each case must be labeled by an integer or character constant or constant expression. If a case matches the expression value, execution starts at that case. The case labeled default is executed if none of the other cases is satisfied. A default is optional; if it isn’t there and if none of the cases matches, no action at all takes place. Cases and default can occur in any order. Cases must all be different.
The break statement causes an immediate exit from the switch. Because cases serve just as labels, after the code for one case is done, execution falls through to the next unless you take explicit action to escape, break and return are the most common ways to leave a switch. A break statement can also be used to force an immediate exit from while, for and do loops as well, as will be discussed later in this chapter.
Falling through cases is a mixed blessing. On the positive side, it allows multiple cases for a single action, as with the blank, tab or newline in this example. But it also implies that normally each case must end with a break to prevent falli ng throu gh to the next. Falling through from one case ro^kriSther is not robust, being prone To disintegration when the program is modified. With the exception of multiple labels for a single computation, fall-throughs should be used sparingly.
As a matter of good form, put a break after the last case (the default here) even though it’s logically unnecessary. Some day when another case gets added at the end, this bit of defensive programming will save you.
Write a function expand (s, t) which converts characters like newline and tab into visible escape sequences like \n and \t as it copies the string s to t. Use a switch.
Each step does its part, and leaves things in a clean state for the next. The whole process terminates on the first character that could not be part of a number.
The advantages of keeping loop control centralized are even more obvious when there are several nested loops. The following function is a Shell sort for sorting an array of integers. The basic idea of the Shell sort is that in early stages, far-apart elements are compared, rather than adjacent ones, as in simple interchange sorts. This tends to eliminate large amounts of disorder quickly, so later stages have less work to do. The interval between compared elements is gradually decreased to one, at which point the sort effectively becomes an adjacent interchange method.
There are three nested loops. The outermost loop controls the gap between compared elements, shrinking it from n/2 by a factor of two each pass until it becomes zero. The middle loop compares each pair of elements that is separated by gap; the innermost loop reverses any that are out of order. Since gap is eventually reduced to one, all elements are eventually ordered correctly. Notice that the generality of the for makes the outer loopiit the same form as the others, even though it is not an arithmetic progression.
The commas that separate function arguments, variables in declarations, etc., are not comma operators, and do not guarantee left to right evaluation.
The statement is executed, then expression is evaluated. If it is true, statement is evaluated again, and so on. If the expression becomes false, the loop terminates.
The do-while is necessary, or at least convenient, since at least one character must be installed in the array s, regardless of the value of n. We also used braces around the single statement that makes up the body of the do-while, even though they are unnecessary, so the hasty reader will not mistake the while part for the beginning of a while loop.
In a 2’s complement number representation, our version of itoa does not handle the largest negative number, that is, the value of n equal to — (2 wordslze-1 ). Explain why not. Modify it to print that value correctly, regardless of the machine it runs on.
Write the analogous function itob(n, s) which converts the unsigned integer n into a binary character representation in s. Write itoh, which converts an integer to hexadecimal representation.
Write a version of itoa which accepts three arguments instead of two. The third argument is a minimum field width; the converted number must be padded with blanks on the left if necessary to make it wide enough.
It is sometimes convenient to be able to control loop exits other than by testing at the top or bottom. The break statement provides an early exit from for, while, and do, just as from switch. A break statement causes the innermost enclosing loop (or switch) to be exited immediately.
The following program removes trailing blanks and tabs from the end of each line of input, using a break to exit from a loop when the rightmost non-blank, non-tab is found.
This is inferior to the previous version, because the test is harder to understand. Tests which require a mixture of &&, II, !, or parentheses should generally be avoided.
As an example, this fragment processes only positive elements in the array a; negative values are skipped.
The continue statement is often used when the part of the loop that follows is complicated, so that reversing a test and indenting another level would nest the program too deeply.
C provides the infinitely-abusable goto statement, and labels to branch to. Formally, the goto is never necessary, and in practice it is almost always easy to write code without it. We have not used goto in this book.
Although we are not dogmatic about the matter, it does seem that goto statements should be used sparingly, if at all.
Functions break large computing tasks into smaller ones, and enable people to build on what others have done instead of starting over from scratch. Appropriate functions can often hide details of operation from parts of the program that don’t need to know about them, thus clarifying the whole, and easing the pain of making changes.
C has been designed to make functions efficient and easy to use; C programs generally consist of numerous small functions rather than a few big ones. A program may reside on one or more source files in any convenient way; tfie source files may be compiled separately and loaded together, along with previously compiled functions from libraries. We will not go into that process here, since the details vary according to the local system.
Most programmers are familiar with “library” functions for input and output (getchar, putchar) and numerical computations (sin, cos, sqrt) . In this chapter we will show more about writing new functions.
Although it’s certainly possible to put the code for all of this in the main routine, a better way is to use the natural structure to advantage by making each part a separate function. Three small pieces are easier to deal with than one big one, because irrelevant details can be buried in the functions, and the chance of unwanted interactions minimized. And the pieces may even be useful in their own right.
Given this much design, filling in the details of the program is straightforward. Here is the whole thing, so you can see how the pieces fit together. For now, the pattern to be searched for is a literal string in the argument of index, which is not the most general of mechanisms. We will return shortly to a discussion of how to initialize character arrays, and in the program is run. This is also a new version of getline; you might find it instructive to compare it to the one in Chapter 1 .
The calling function is free to ignore the returned value if it wishes. Furthermore, there need be no expression after return; in that case, no value is returned to the caller. Control also returns to the caller with no value when execution “falls off the end” of the function by reaching the closing right brace. It is not illegal, but probably a sign of trouble, if a function returns a value from one place and no value from another. In any case, the “value” of a function which does not return one is certain to be garbage. The C verifier lint checks for such errors.
The cc command uses the “.c” versus “.o” naming convention to distinguish source files from object files.
Write the function rindex(s, t), which returns the position of the rightmost occurrence of t in s, or -1 if there is none.
Second, and just as important, the calling routine must state that atof returns a non- int value. The declaration is shown in the following primitive desk calculator (barely adequate for check-book balancing), which reads one number per line, optionally preceded by a sign, and adds them all up, printing the sum after each input.
Extend atof so it handles scientific notation of the form where a floating point number may be followed by e or E and an optionally signed exponent.
In Chapter 1 we discussed the fact that function arguments are passed by value, that is, the called function receives a private, temporary copy of each argument, not its address. This means that the function cannot affect the original argument in the calling function. Within a function, each argument is in effect a local variable initialized to the value with which the function was called.
When an array name appears as an argument to a function, the location of the beginning of the array"s passed; elements are not copied. The function can alter elements of the array by subscripting from this location. The effect is that arrays are passed by reference. In Chapter 5 we will discuss The ' use of pointers to permit functions to affect non-arrays in calling functions.
By the way, there is no entirely satisfactory way to write a portable function that accepts a variable number of arguments, because there is no portable way for the called function to determine how many arguments were actually passed to it in a given call. Thus, you can’t write a truly portable function that will compute the maximum of an arbitrary number of arguments, as will the MAX built-in functions of Fortran and PL/I.
It is generally safe to deal with a variable number of arguments if the called function doesn’t use an argument which was not actually supplied, and if the types are consistent, printf , the most common C function with a variable number of arguments, uses information from the first argument to determine how many other arguments are present and what their types are. It fails badly if the caller does not supply enough arguments or if the types are not what the first argument says. It is also non-portable and must be modified for different environments.
Alternatively, if the arguments are of known types it is possible to mark the end of the argument list in some agreed-upon way, such as a special argument value (often zero) that stands for the end of the arguments.
A C program consists of a set of external objects, which are either variables or functions. The adjective “external” is used primarily in contrast to “internal,” which describes the arguments and automatic variables defined inside functions. External variables are defined outside any function, and are thus potentially available to many functions. Functions themselves are always external, because C does not allow functions to be defined inside _ _ other functions . By default, external variables are also "global," so that all references to such a variable by the same name (even from functions compiled separately) are references to the same thing. In this sense, external variables are analogous to Fortran COMMON or PL/I EXTERNAL. We will see later how to define external variables and functions that are not globally available, but are instead visible only within a single source file.
Because external variables are globally accessible, they provide an alternative to function arguments and returned values for communicating data between functions. Any function may access an external variable by referring to it by name, if the name has been declared somehow.
If a large number of variables must be shared among functions, external variables are more convenient and efficient than long argument lists. As pointed out in Chapter 1, however, this reasoning should be applied with some caution, for it can have a bad effect on program structure, and lead to programs with many data connections between functions.
A second reason for using external variables concerns initialization. In particular, external arrays may be initialized, but automatic arrays may not. We will treat initialization near the end of this chapter.
The implementation is quite simple. Each operand is pushed onto a stack; when an operator arrives, the proper number of operands (two for binary operators) are popped, the operator applied to them, and the result pushed back onto the stack. In the example above, for instance, 1 and 2 are pushed, then replaced by their difference, —1. Next, 4 and 5 are pushed and then replaced by their sum, 9. The product of —1 and 9, which is —9, replaces them on the stack. The = operator prints the top element without removing it (so intermediate steps in a calculation can be checked) .
The main design decision that has not yet been discussed is where the stack is, that is, what routines access it directly. One possibility is to keep it in main, and pass the stack and the current stack position to the routines that push and pop it. But main doesn’t need to know about the variables that control the stack; it should think only in terms of pushing and popping. So we have decided to make the stack and its associated information external variables accessible to the push and pop functions but not to main.
Translating this outline into code is easy enough. The main program is primarily a big switch on the type of operator or operand; this is perhaps a more typical use of switch than the one shown in Chapter 3.
The command c clears the stack, with a function clear which is also used by push and pop in case of error. We’ll return to getop in a moment.
Notice also that because + and * are commutative operators, the order in which the popped operands are combined is irrelevant, but for the - and / operators, the left and right operands must be distinguished.
The scope of a name is the part of the program over which the name is defined. For an automatic variable declared at the beginning of a function, the scope is the function in which the name is declared, and variables of the same name in different functions are unrelated. The same is true of the arguments of the function.
On the other hand, if an external variable is to be referred to before it is defined, or if it is defined in a different source file from the one where it is being used, then an extern declaration is mandatory.
There must be only one definition of an external variable among all the files that make up the source program; other files may contain extern declarations to access it. (There may also be an extern declaration in the file containing the definition.) Any initialization of an external variable goes only with the definition. Array sizes must be specified with the definition, but are optional with an extern declaration.
Because the extern declarations in file 2 lie ahead of and outside the three functions, they apply to all; one set of declarations suffices for all of file 2.
For larger programs, the # include file inclusion facility discussed later in this chapter allows one to keep only a single copy of the extern declarations for the program and have that inserted in each source file as it is being compiled.
The routine is substantially complicated by an attempt to handle the situation properly when an input number is too long, getop reads digits (perhaps with an intervening decimal point) until it doesn’t see any more, but only stores the ones that fit. If there was no overflow, it returns NUMBER and the string of digits. If the number was too long, however, getop discards the rest of the input line so the user can simply retype the line from the point of error; it returns TOOBIG as the overflow signal.
The problem would be solved if it were possible to “un-read” the unwanted character. Then, every time the program reads one character too many, it could push it back on the input, so the rest of the code could behave as if it had never been read. Fortunately, it’s easy to simulate ungetting a character, by writing a pair of cooperating functions, getch delivers the next input character to be considered; ungetch puts a character back on the input, so that the next call to getch will return it again.
How they work together is simple, ungetch puts the pushed-back characters into a shared buffer — a character array, getch reads from the buffer if there is anything there; it calls getchar if the buffer is empty. There must also be an index variable which records the position of the current character inihe buffer.
We have used an array for the pushback, rather than a single character, since the generality may come in handy later.
Suppose that there will never be more than one character of pushback. Modify getch and ungetch accordingly.
Our getch and ungetch do not handle a pushed-back EOF in a portable way. Decide what their properties ought to be if an EOF is pushed back, then implement your design.
Static variables are a third class of storage, in addition to the extern and automatic that we have already met.
Static storage, whether internal or external, is specified by prefixing the normal declaration with the word static. The variable is external if it is defined outside of any function, and internal if defined inside a function.
Normally, functions are external objects; their names are known globally. It is possible, however, for a function to be declared static; this makes its name unknown outside of the file in which it is declared.
In C, “static” connotes not only permanence but also a degree of what might be called “privacy.” Internal static objects are known only inside one function; external static objects (variables or functions) are known only within the source file in which they appear, and their names do not interfere with variables or functions of the same name in other files.
The fourth and final storage class is called register. A register declaration advises the compiler that the variable in question will be heavily used. When possible, register variables are placed in machine registers, which may result in smaller and faster programs.
In practice, there are some restrictions on register variables, reflecting the realities of underlying hardware. Only a few variables in each function may be kept in registers, and only certain types are allowed. The word register is ignored for excess or disallowed declarations. And it is not possible to take the address of a register variable (a topic to be covered in example, on the PDP-11, only the first three register declarations in a function are effective, and the types must be int, char, or pointer.
C is not a block-structured language in the sense of PL/I or Algol, in that functions may not be defined within other functions.
Initialization has been mentioned in passing many times so far, but always peripherally to some other topic. This section summarizes some of the rules, now that we have discussed the various storage classes.
In the absence of explicit initialization, external and static variables are guaranteed to be initialized to zero; automatic and register variables have undefined (i.e., garbage) values.
In effect, initializations of automatic variables are just shorthand for assignment statements. Which form to prefer is largely a matter of taste. We have generally used explicit assignments, because initializers in declarations are harder to see.
These initializations are actually unnecessary since all are zero, but it’s good form to make them explicit anyway. If there are fewer initializers than the specified size, the others will be zero. It is an error to have too many initializers. Regrettably, there is no way to specify repetition of an initializer, nor to initialize an element in the middle of an array without supplying all the intervening values as well.
When the size of an array of any type is omitted, the compiler will compute (three characters plus the terminating \0).
C functions may be used recursively; that is, a function may call itself either directly or indirectly. One traditional example involves printing a number as a character string. As we mentioned before, the digits are generated in the wrong order: low-order digits are available before high-order digits, but they have to be printed the other way around.
There are two solutions to this problem. One is to store the digits in an array as they are generated, then print them in the reverse order, as we did in Chapter 3 with itoa. The first version of printd follows this pattern.
The alternative is a recursive solution, in which each call of printd first calls itself to cope with any leading digits, then prints the trailing digit.
When a function calls itself recursively, each invocation gets a fresh set of all the automatic variables, quite independent of the previous set. Thus in printd (123) the first printd has n = 123. It passes 12 to a second P^iutd, then prints 3 when that one returns. In the same way, the second printd passes 1 to a third (which prints it), then prints 2.
Recursion generally provides no saving in storage, since somewhere a stack of the values being processed has to be maintained. Nor will it be faster. But recursive code is more compact, and often much easier to write and understand. Recursion is especially convenient for recursively defined data structures like trees; we will see a nice example in Chapter 6.
Adapt the ideas of printd to write a recursive version of itoa; that is, convert an integer into a string with a recursive routine.
Write a recursive version of the function reverse (s), which reverses the string s.
C provides certain language extensions by means of a simple macro preprocessor. The #define capability which we have used is the most common of these extensions; another is the ability to include the contents of other files during compilation.
A definition of the form calls for a macro substitution of the simplest kind — replacing a name by a string of characters. Names in #define have the same form as C identifiers; the replacement text is arbitrary. Normally the replacement text is the rest of the line; a long definition may be continued by placing a \ at the end of the line to be continued. The “scope” of a name defined with #define is from its point of definition to the end of the source file. Names may be redefined, and a definition may use previous definitions. Substitutions do not take place within quoted strings, so, for example, if YES is a defined name, there would be no substitution in printf ( "YES" ) .
This provides a “maximum function” that expands into in-line code rather than a function call. So long as the arguments are treated consistently, this macro will serve for any data type; there is no need for different kinds of max for different data types, as there would be with functions.
Nonetheless, macros are quite valuable. One practical example is the standard I/O library to be described in Chapter 7, in which getchar and putchar are defined as macros (obviously putchar needs an argument), thus avoiding the overhead of a function call per character processed.
A pointer is a variable that containsjhe address of 4not]3^ variable. Pointers are very much used in CTpartTy becauseTfiey are sometimes the only way to express a computation, and partly because they usually lead to more compact and efficient code than can be obtained in other ways.
Pointers have been lumped with the goto statement as a marvelous way to create impossible-to-understand programs. This is certainly true when they are used carelessly, and it is easy to create pointers that point somewhere unexpected. With discipline, however, pointers can also be used to achieve clarity and simplicity. This is the aspect that we will try to illustrate.
The declaration of x and y is what we’ve seen all along. The declaration of the pointer px is new.
You should also note the implication in the declaration that a pointer is constrained to point to a particular kind of object.
Pointers can occur in expressions. For example, if px points to the integer x, then *px can occur in any context where x could.
The parentheses are necessary in this last example; without them, the expression would increment px instead of what it points to, because unary operators like * and ++ are evaluated right to le ft.
Because of call by value, swap can’t affect the arguments a and b in the routine that called it.
Since the operator & gives the address of a variable, &a is a pointer to a. In swap itself, the arguments are declared to be pointers, and the actual operands are accessed through them.
One common use of pointer arguments is in functions that must return more than a single value. (You might say that swap returns two values” the new values of its arguments.) As an example, consider a function get int which performs free-format input conversion by breaking a stream of characters into integer values, one integer per call, getint has to return the value it found, or an end of file signal when there is no more input. These values have to be returned as separate objects, for no matter what value is used for EOF, that could also be the value of an input integer.
One solution, which is based on the input function scanf that we will describe in Chapter 7, is to have getint return EOF as its function value if it found end of file; any other returned value signals a normal integer. The numeric value of the integer it found is returned through an argument, which must be a pointer to an integer. This organization separates end of file status from numeric values.
Each call sets v to the next integer found in the input. Notice that it is essential to write &v instead of v as the argument of getint. Using plain v is likely to cause an addressing error, since getint believes it has been handed a valid pointer.
Throughout getint, *pn is used as an ordinary int variable. We have also used getch and ungetch (described in Chapter 4) so the one extra character that must be read can be pushed back onto the input.
In C, there is a strong relationship between pointerejr^arrays, strong enough that pointerran3^army^ean)Tll^uTd~brTreated simultaneously. Any operation which can be achieved by array subscripting can also be done with pointers. The pointer version will in general be faster but, at least to the uninitiated, somewhat harder to grasp immediately.
The correspondence betweerTTndexing and pointer arithmetic is evidently very close. In fact, a reference to an array is converted by the compiler to a pointer to the beginning of the array. The effect is that anarjajL nam e is a pointer expression. This has quite a few useful implications.
There is one difference between an array name and a pointer that miist . be kept in mind. A pointer is a variable, so pa=a and pa++ are sensible operations. But an array name is a constant , not a variable: constructions like a=pa or a++ or p=&a are illegal.
So as far as f is concerned, the fact that the argument really refers to part of a larger array is of no consequence.
C is consistent and regular in its approach to address arithmetic; its integration of pointers, arrays and address arithmetic is one of the major strengths of the language. Let us illustrate some of its properties by writing a rudimentary storage allocator (but useful in spite of its simplicity). There are two routines: alloc (n) returns a pointer p to n consecutive character positions, which can be used by the caller of alloc for storing characters; free (p) releases the storage thus acquired so it can be later re-used. The routines are “rudimentary” because the calls to free must be made in the opposite order to the calls made on alloc. That is, the storage managed by alloc and free is a stack, or last-in, first-out list. The standard C library provides analogous functions which have no such restrictions, and in ever, many applications really only need a trivial alloc to dispense little pieces of storage of unpredictable sizes at unpredictable times.
The simplest implementation is to have alloc hand out pieces of a large character array which we will call allocbuf. This array is private to allgc and free. Since they deal in pointers, not aVfa7 > Wmce^no\)'thet routineTneed^iaTow the name of the array, which can be declared external static, that is, local to the source file containing alloc and free, and invisible outside it. In practical implementations, the array may well not even have a name; it might instead be obtained by asking the operating system for a pointer to some unnamed block of storage.
The other information needed is how much of allocbuf has been used. We use a pointer to the next free element, called allocp. When alloc is asked for n characters, it checks to see if there is enough room left in allocbuf. If so, alloc returns the current value of allocp (i.e., the beginning of the free block), then increments it by n to point to the next free area, free(p) merely sets allocp to p if p is inside allocbuf.
In its declaration, p is initialized to s, that is, to point to the first character.
Because p points to characters, p++ advances p to the next character each time, and d-s gives the num ber of characters advanced over, that is, the string length. Pointer arithmetic is consistent: if we hadTieen dealing with f loat’s, which occupy more storage than char’s, and if p were a pointer to float, p++ would advance to the next float. Thus we could write another version of alloc which maintains, let us say, float’s instead of char’s, merely by changing char to float throughout alloc and free. All the pointer manipulations automatically take into account the size of the object pointed to, so nothing else has to be altered.
Other than the operations mentioned here (adding or subtracting a pointer and an integer; subtracting or comparing two pointers), all other pointer arithmetic is illegal. It is not permitted to add two pointers, or to multiply or divide or shift or mask them, or to add float or double to them.
This is an array of characters. In the internal representation, the compiler terminates the array with the character \0 so that programs can find the end. The length in storage is thus one more than the number of characters between the double quotes.
We will illustrate more aspects of pointers and arrays by studying two useful functions from the standard I/O library to be discussed in Chapter 7.
Although this may seem cryptic at first sight, the notational convenience is considerable, and the idiom should be mastered, if for no other reason than that you will see it frequently in C programs.
The second routine is strcmp(s, t), which compares the character strings s and t, and returns negative, zero or positive according as s is lexicographically less than, equaftoT or greater' thafft The value returned is obtained by subtracting the characters at the first position where s and t disagree.
Write a pointer version of the function strcat which we showed in Chapter 2: strcat (s, t) copies the string t to the end of s.
C provides for rectangular multi-dimensional arrays, although in practice they tend to be much less used than arrays of pointers. In this section, we will show some of their properties.
Since pointers are variables themselves, you might expect that there would be uses for arrays of pointers. This is indeed the case. Let us illustrate by writing a program that will sort a set of text lines into alphabetic order, a stripped-down version of the UNIX utility sort.
In Chapter 3 we presented^ Shell sort function that would sort an array of integers. The same fjl gorit hpi will work, except that now we have to deal with lines of text, which are of different lengths, and which, unlike integers, can't be cornpared or moved iTi r single^ operation. We need a data representation that will cope efficientlyand cbnvemenfly with variable-length text lines.
This is where the array of pointers enters. If the lines to be sorted are stored end-to-end in one long character array (maintained by alloc, perhaps), then each line can be accessed by a pointer to its first character.
The pointers themselves can be stored in an array. Two lines can be compared by passing their pointers to strcmp. When two out-of-order lines have to be exchanged, the pointers in the pointer array are exchanged, not the text lines themselves. This eliminates the twin problems of complicated SUy^gg^man^^ and high overhead that would go with movingThe"" actual lines.
As usual, it’s best to divide the program into functions that match this natural division, with the main routine controlling things.
Let us defer the sorting step for a moment, and concentrate on the data structure and the input and output. The input routine has to collect and save the characters of each line, and build an array of pointers to the lines. It will also have to count the number of input lines, since that information is needed for sorting and printing.
The newline at the end of each line is deleted so it will not affect the order in which the lines are sorted.
With input and output under control, we can proceed to( sorting p The Shell sort from Chapter 3 needs minor changes: the declarations!!^ to be modified, and the comparison operation must be moved into a separate function. The basic algorithm remains the same, which gives us some confidence that it will still work.
Since any individual element of v (alias lineptr) is a character pointer, temp also should be, so one can be copied to the other.
We wrote the program about as straightforwardly as possible, so as to get it working quickly. It might be faster, for instance, to copy the incoming lines directly into an array maintained by readlines, rather than copying them into line and then to a hidden place maintained by alloc. But it’s wiser to make the first draft something easy to understand, and worry about “efficiency” later. The way to make this program significantly faster is probably not by avoiding an unnecessary copy of the input lines. Replacing the Shell sort by something better, like Quicksort, is more likely to make a difference.
In Chapter 1 we pointed out that because while and for loops test the termination condition before executing the loop body even once, they help to ensure that programs will work at their boundaries, in particular with no input. It is illuminating to walk through the functions of the sorting program, checking what happens if there is no input text at all.
Consider the problem of writing a function month_name (n) , which returns a pointer to a character string containing the name of the n-th month. This is an ideal application for an jntemal^^ month_name contains a private array of character strings, and returns a pointer to the proper one when called. The topic of this section is how that array of names is initialized.
The declaration of name, which is an array of character pointers, is the same as lineptr in the sorting example. The initializer is simply~a list of character strings; each is assigned to the corresponding position in the array. More precisely, t he ch aracters of the i-th string are placed somewhere else, and a pointer to them is stored jn name[i]. “Siricethe sizeof the array name is not specified, the compiler itself counts the initializers and fills in the correct number.
Newcomers to C are sometimes confused about the difference between a two-dimensional array and an array of pointers, such as name in the example above. Given the declarations the usage of a and b may be similar, in that a [5] [5] and b[5] [5] are both legal references to a single int. But a is a true array: all 100 storage cells have been allocated, and the conventional rectangular subscript calculation is done to find any given element. For b, however, the declaration only allocates 10 pointers; each must be set to point to an array of integers. Assuming that each does point to a ten-element array, then there will be 100 storage cells set aside, plus the ten cells for the pointers. Thus the array of pointers uses slightly more space, and may require an explicit initialization step. But it has two advantages: accessing an element is done by indirection through a pointer rather than by a multiplication and an addition, and the rows of the array may be of different lengths. That is, each element of b need not point to a ten-element vector; some may point to two elements, some to twenty, and some to none at all.
Although we have phrased this discussion in terms of integers, by far the most frequent use of arrays of pointers is like that shown in month_name: to store character strings of diverse lengths.
Rewrite the routines day_of _year and month_day with pointers instead of indexing.
In environments that support C, there is a way to pass command-line arguments or parameters to a program when it begins executing. When main is called to begin execution, it is called with two arguments. The first (conventionally called argc) is the number of command-line arguments the program was invoked with; the second (argv) is a pointer to an array of character strings that contain the arguments, one per string. Manipulating these character strings is a common use of multiple levels of pointers.
By convention, argv[0] is the name by which the program was invoked, so argc is at least 1. In the example above, argc is 3, and argv [0] , argv[1] and argv [2] are “echo”, “hello,”, and “world” respectively. The first real argument is argv [1 ] and the last is argv[argc-1 ] .
Since argv is a pointer to an array of pointers, there are several ways to write this program that involve manipulating the pointer rather than indexing an array. Let us show two variations.
Since argv is a pointer to the beginning of the array of argument strings, incrementing it by 1 (++argv) makes it point at the original argv [ 1 ] instead of argv[0] . Each successive increment moves it along to the next argument; *argv is then the pointer to that argument. At the same time, argc is decremented; when it becomes zero, there are no arguments left to print.
This version shows that the format argument of printf can be an expression just like any of the others. This usage is not very frequent, but worth remembering.
As a second example, let us make some enhancements to the patternfinding program from Chapter 4. If you recall, we wired the search pattern deep into the program, an obviously unsatisfactory arrangement. Following the lead of the UNIX utility grep, let us change the program so the pattern to be matched is specified by the first argument on the command line.
Modify the programs entab and detab (written as exercises in Chapter 1) to accept a list of tab stops as arguments. Use the normal tab settings if there are no arguments.
In C, a function itself is not a variable, but it is possible to define a pointer to a function, which can be manipulated, passed to functions, placed in arrays, and so on. We will illustrate this by modifying the sorting procedure written earlier in this chapter so that if the optional argument -n is given, it will sort the input lines numerically instead of lexicographically.
A sort often consists of three parts — a comparison which determines the ordering of any pair of objects, an exchange which reverses their order, and a sorting algorithm which makes comparisons and exchanges until the objects are in order. The sorting algorithm is independent of the comparison and exchange operations, so by passing different comparison and exchange functions to it, we can arrange to sort by different criteria. This is the approach taken in our new sort.
There are a variety of other options that can be added to the sorting program; some make challenging exercises.
Modify sort to handle a -r flag, which indicates sorting in reverse (decreasing) order. Of course -r must work with -n.
Add the option -f to fold upper and lower case together, so that case distinctions are not made during sorting: upper and lower case data are sorted together, so that a and A appear adjacent, not separated by an entire case of the alphabet.
Add the -d (“dictionary order”) option, which makes comparisons only on letters, numbers and blanks. Make sure it works in conjunction with -f .
The traditional example of a structure is the payroll record: an “employee” is described by a set of attributes such as name, address, social security number, salary, etc. Some of these in turn could be structures: a name has several components, as does an address and even a salary.
Structures help to organize complicated data, particularly in large programs, because in many situations they permit a group of related variables to be treated as a unit instead of as separate entities. In this chapter we will try to illustrate how structures are used. The programs we will use are bigger than many of the others in the book, but still of modest size.
The keyword struct introduces a structure declaration, which is a list of declarations enclosed in braces. An optional name called a structure tag may follow the word struct (as with date here). The tag names this kind of structure, and can be used subsequently as a shorthand for the ’detailed declaration.
The elements or variables mentioned in a structure are called members. A structure member or tag and an ordinary (i.e., non-member) variable can have the same name without conflict, since they can always be distinguished by context. Of course as a matter of style one would normally use the same names only for closely related objects.
There are a number of restrictions on C structures. The essential rules are that the only operations that you can perform on a structure are take its address with &, and access one of its members. This implies that structures may not be assigned to or copied as a unit, and that they can not be passed to or returned from functions. (These restrictions will be removed in forthcoming versions.) Pointers to structures do not suffer these limitations, however, so structures and functions do work together comfortably. Finally, automatic structures, like automatic arrays, cannot be initialized; only external or static structures can.
For completeness here is the other function, month_day, rewritten to use the structure.
In the same way, *p->y fetches whatever y points to; *p->y++ increments y after accessing whatever it points to (just like *s++); (*p->y)++ increments whatever y points to; and *p++->y increments p after accessing whatever y points to.
We will show the function getword in a moment; for now it suffices to say that it returns LETTER each time it finds a word, and copies the word into its first argument.
The quantity NKEYS is the number of keywords in keytab. Although we could count this by hand, it’s a lot easier and safer to do it by machine, especially if the list is subject to change. One possibility would be to terminate the list of initializers with a null pointer, then loop along keytab until the end is found.
Now for the function getword. We have actually written a more general getword than is necessary for this program, but it is not really much more complicated, getword returns the next “word” from the input, where a word is either a string of letters and digits beginning with a letter, or a single character. The type of the object is returned as a function value; it is LETTER if the token is a word, EOF for end of file, or the character itself if it is non-alphabetic.
Make this modification to getword and measure the change in speed of the program.
Write a version of the keyword-counting program which does not count occurrences contained within quoted strings.
To illustrate some of the considerations involved with pointers and arrays of structures, let us write the keyword-counting program again, this time using pointers instead of array indices.
The external declaration of keytab need not change, but main and binary do need modification.
There are several things worthy of note here. First, the declaration of binary must indicate that it returns a pointer to the structure type key, instead of an integer; this is declared both in main and in binary. If binary finds the word, it returns a pointer to it; if it fails, it returns NULL.
You should also study the initializers for low and high. It is possible to initialize a pointer to the address of a previously defined object; that is precisely what we have done here.
This is mostly a matter of personal taste; pick the form you like and hold to it.
One solution is to keep the set of words seen so far sorted at all times, by placing each word into its proper position in the order as it arrives. This shouldn’t be done by shifting words in a linear array, though — that also takes too long. Instead we will use a data structure called a binary tree.
The code for the whole program is surprisingly small, given a handful of supporting routines that we have already written. These are getword, to fetch each input word, and alloc, to provide space for squirreling the words away.
The main routine simply reads words with getword and installs them in the tree with tree.
Storage for the new node is fetched by a routine talloc, which is an adaptation of the alloc we wrote earlier. It returns a pointer to a free space suitable for holding a tree node. (We will discuss this more in a moment.) The new word is copied to a hidden place by strsave, the count is initialized, and the two children are made null. This part of the code is executed only at the edge of the tree, when a new node is being added. We have (unwisely for a production program) omitted error checking on the values returned by strsave and talloc.
A practical note: if the tree becomes “unbalanced” because the words don’t arrive in random order, the running time of the program can grow too fast. As a worst case, if the words are already in order, this program does an expensive simulation of linear search. There are generalizations of the binary tree, notably 2-3 trees and AVL trees, which do not suffer from this worst-case behavior, but we will not describe them here.
Alignment requirements can generally be satisfied easily, at the cost of some wasted space, merely by ensuring that the allocator always returns a pointer that meets all alignment restrictions. For example, on the PDP-11 it is sufficient that alloc always return an even pointer, since any type of object may be stored at an even address. The only cost is a wasted character on odd-length requests. Similar actions are taken on other machines. Thus the implementation of alloc may not be portable, but the usage is. The alloc of Chapter 5 does not guarantee any particular alignment; in Chapter 8 we will show how to do the job right.
This is more than is needed for current compilers, but represents the safest course for the future.
Write a program which reads a C program and prints in alphacharacters, but different somewhere thereafter. (Make sure that 7 is a parameter).
Write a basic cross-referencer: a program which prints a list of all words in a document, and, for each word, a list of the line numbers on which it occurs.
Write a program which prints the distinct words in its input sorted into decreasing order of frequency of occurrence. Precede each word by its count.
There are two major routines that manipulate the names and replacement texts. install (s, t ) records the name s and the replacement text t in a table; s and t are just character strings, lookup (s) searches for s in the table, and returns a pointer to the place where it was found, or NULL if it wasn’t there.
A block in the chain is a structure containing pointers to the name, the replacement text, and the next block in the chain. A null next-pointer marks the end of the chain.
The hashing process produces a starting index in the array hashtab; if the string is to be found anywhere, it will be in the chain of blocks beginning there. The search is performed by lookup. If lookup finds the entry already present, it returns a pointer to it; if not, it returns NULL.
Otherwise, a completely new entry is created, install returns NULL if for any reason there is no room for a new entry.
Write a routine which will remove a name and definition from the table maintained by lookup and install.
Implement a simple version of the #define processor suitable for use with C programs, based on the routines of this section. You may also find getch and ungetch helpful.
When storage space is at a premium, it may be necessary to pack several objects into a single machine word; one especially common use is a set of single-bit flags in applications like compiler symbol tables. Externallyimposed data formats, such as interfaces to hardware devices, also often require the ability to get at pieces of a word.
Imagine a fragment of a compiler that manipulates a symbol table. Each identifier in a program has certain information associated with it, for example, whether or not it is a keyword, whether or not it is external and/or static, and so on. The most compact way to encode such information is a set of one-bit flags in a single char or int.
This defines a variable called flags that contains three 1-bit fields. The number following the colon represents the field width in bits. The fields are declared unsigned to emphasize that they really are unsigned quantities.
A field may not overlap an int boundary; if the width would cause this to happen, the field is aligned at the next int boundary. Fields need not be named; unnamed fields (a colon and width only) are used for padding. The special width 0 may be used to force alignment at the next int boundary.
There are a number of caveats that apply to fields. Perhaps most significant, fields are assigned left to right on some machines and right to left on others, reflecting the nature of different hardware. This means that although fields are quite useful for maintaining internally-defined data structures, the question of which end comes first has to be carefully considered when picking apart externally-defined data.
Other restrictions to bear in mind: fields are unsigned; they may be stored only in int’s (or, equivalently, unsigned’s); they are not arrays; they do not have addresses, so the & operator cannot be applied to them.
A union is a variable which may hold (at different times) objects of different types and sizes, with the compiler keeping track of size and alignment requirements. Unions provide a way to manipulate different kinds of data in a single area of storage, without embedding any machine-dependent information in the program.
As an example, again from a compiler symbol table, suppose that constants may be int’s, float’s or character pointers. The value of a particular constant must be stored in a variable of the proper type, yet it is most convenient for table management if the value occupies the same amount of storage and is stored in the same place regardless of its type. This is the purpose of a union — to provide a single variable which can legitimately hold any one of several types. As with fields, the syntax is based on structures.
The variable uval will be large enough to hold the largest of the three types, regardless of the machine it is compiled on — the code is independent of hardware characteristics. Any one of these types may be assigned to uval and then used in expressions, so long as the usage is consistent: the type retrieved must be the type most recently stored. It is the responsibility of the programmer to keep track of what type is currently stored in a union; the results are machine dependent if something is stored as one type and extracted as another.
In effect, a union is a structure in which all members have offset zero, the structure is big enough to hold the “widest” member, and the alignment is appropriate for all of the types in the union. As with structures, the only operations currently permitted on unions are accessing a member and taking the address; unions may not be assigned to, passed to functions, or returned by functions. Pointers to unions can be used in a manner identical to pointers to structures.
The storage allocator in Chapter 8 shows how a union can be used to force a variable to be aligned on a particular kind of storage boundary.
Notice that the type being declared in a typedef appears in the position of a variable name, not right after the word typedef. Syntactically, typedef is like the storage classes extern, static, etc. We have also used upper case letters to emphasize the names.
There are two main reasons for using typedef declarations. The first is to parameterize a program against portability problems. If typedef ’s are used for data types which may be machine dependent, only the typedef’s need change when the program is moved. One common situation is to use typedef names for various integer quantities, then make an appropriate set of choices of short, int and long for each host machine.
The second purpose of typedef’s is to provide better documentation for a program — a type called TREEPTR may be easier to understand than one declared only as a pointer to a complicated structure.
Finally, there is always the possibility that in the future the compiler or some other program such as lint may make use of the information contained in typedef declarations to perform some extra checking of a program.
Input and output facilities are not part of the C language, so we have de-emphasized them in our presentation thus far. Nonetheless, real programs do interact with their environment in much more complicated ways than those we have shown before. In this chapter we will describe “the standard I/O library,” a set of functions designed to provide a standard I/O system for C programs. The functions are intended to present a convenient programming interface, yet reflect only operations that can be provided on most modern operating systems. The routines are efficient enough that users should seldom feel the need to circumvent them “for efficiency” regardless of how critical the application. Finally, the routines are meant to be “portable,” in the sense that they will exist in compatible form on any system where C exists, and that programs which confine their system interactions to facilities provided by the standard library can be moved from one system to another essentially without change.
We will not try to describe the entire I/O library here; we are more interested in showing the essentials of writing C programs that interact with their operating system environment.
Output produced by printf also finds its way to the standard output, and calls to putchar and printf may be interleaved.
The “functions” i supper and tolower Are actually macros defined, in stdio.h. The macro isupper tests whether its argument is an upper case letter, returning non-zero if it is, and zero if not. The macro tolower converts an upper case letter to lower case. Regardless of how these functions are implemented on a particular machine, their external behavior is the same, so programs that use them are shielded from knowledge of the character set.
As an aside, in the standard I/O library the “functions” getchar and putchar can actually be macros, and thus avoid the overhead of a function call per character. We will show how this is done in Chapter 8.
The two routines printf for output and scanf for input (next section) permit translation to and from character representations of numerical quantities. They also allow generation or interpretation of formatted lines. We have used printf informally throughout the previous chapters; here is a more complete and precise description.
A minus sign, which specifies left adjustment of the converted argument in its field.
A digit string specifying a minimum field width. The converted number will be printed in a field at least this wide, and wider if necessary. If the converted argument has fewer characters than the field width it will be padded on the left (or right, if the left adjustment indicator has been given) to make up the field width. The padding character is blank normally and zero if the field width was specified with a leading zero (this zero does not imply an octal field width) .
A digit string (the precision), which specifies the maximum number of characters to be printed from a string, or the number of digits to be printed to the right of the decimal point of a float or double.
A length modifier 1 (letter ell), which indicates that the corresponding data item is a long rather than an int.
Note that the precision does not determine the number of significant digits printed in f format, g Use %e or %f, whichever is shorter; non-significant zeros are not printed.
If the character after the % is not a conversion character, that character is printed; thus % may be printed by %%.
Most of the format conversions are obvious, and have been illustrated in earlier chapters. One exception is precision as it relates to strings. The following table shows the effect of a variety of specifications in printing “hello, world” (12 characters). We have put colons around each field so you can see its extent.
A warning: printf uses its first argument to decide how many arguments follow and what their types are. It will get confused, and you will get nonsense answers, if there are not enough arguments or if they are the wrong type.
Write a program which will print arbitrary input in a sensible way. As a minimum, it should print non-graphic characters in octal or hex (according to local custom) , and fold long lines.
The function scanf is the input analog of printf, providing many of the same conversion facilities in the opposite direction.
Ordinary characters (not %) which are expected to match the next nonwhite space character of the input stream.
Conversion specifications, consisting of the character %, an optional assignment suppression character *, an optional number specifying a maximum field width, and a conversion character.
A conversion specification directs the conversion of the next input field. Normally the result is placed in the variable pointed to by the corresponding argument. If assignment suppression is indicated by the * character, however, the input field is simply skipped; no assignment is made. An input field is defined as a string of non-white space characters; it extends either to the next white space character or until the field width, if specified, is exhausted. This implies that scanf will read across line boundaries to find its input, since newlines are white space.
The conversion characters d, o and x may be preceded by 1 (letter ell) to indicate that a pointer to long rather than int appears in the argument list. Similarly, the conversion characters e or f may be preceded by 1 to indicate that a pointer to double rather than float is in the argument list.
Rewrite the desk calculator of Chapter 4 using scanf and/or sscanf to do the input and number conversion.
The programs written so far have all read the standard input and written the standard output, which we have assumed are magically pre-defined for a program by the local operating system.
The question is how to arrange for the named files to be read — that is, how to connect the external names that a user thinks of to the statements which actually read the data.
The rules are simple. Before it can be read or written a file has to be opened by the standard library function fopen. fopen takes an external name (like x.c ory.c), does some housekeeping and negotiation with the operating system (details of which needn’t concern us), and returns an internal name which must be used in subsequent reads or write of the file.
The first argument of fopen is the name of the file, as a character string. The second argument is the mode , also as a character string, which indicates how one intends to use the file. Allowable modes are read ("r"), write ("w"), or append ("a").
If you open a file which does not exist for writing or appending, it is created (if possible) . Opening an existing file for writing causes the old contents to be discarded. Trying to read a file that does not exist is an error, and there may be other causes of error as well (like trying to read a file when you don’t have permission). If there is any error, fopen will return the null pointer value NULL (which for convenience is also defined in stdio.h).
When a program is started, three files are opened automatically, and file pointers are provided for them. These files are the standard input, the standard output, and the standard error output; the corresponding file pointers are called stdin, stdout, and stderr. Normally these are all connected to the terminal, but stdin and stdout may be redirected to files or pipes as described in section 7.2.
For formatted input or output of files, the functions fscanf and fprintf may be used. These are identical to scanf and printf, save that the first argument is a file pointer that specifies the file to be read or written; the control string is the second argument.
The file pointers stdin and stdout are pre-defined in the I/O library as the standard input and standard output; they may be used anywhere an object of type FILE * can be. They are constants, however, not variables, so don’t try to assign to them.
The treatment of errors in cat is not ideal. The trouble is that if one of the files can’t be accessed for some reason, the diagnostic is printed at the end of the concatenated output. That is acceptable if that output is going to a terminal, but bad if it’s going into a file or into another program via a pipeline.
To handle this situation better, a second output file, called stderr, is assigned to a program in the same way that stdin and stdout are. If at all possible, output written on stderr appears on the user’s terminal even if the standard output is redirected.
The program signals errors two ways. The diagnostic output produced by fprintf goes onto stderr, so it finds its way to the user’s terminal instead of disappearing down a pipeline or into an output file.
The program also uses the standard library function exit, which terminates program execution when it is called. The argument of exit is available to whatever process called this one, so the success or failure of the program can be tested by another program that uses this one as a^suh^ process. By convention, a return value of 0 signals that all is well, and various non-zero values signal abnormal situations.
Write a program to compare two files, printing the first line and character position where they differ.
Write a program to print a set of files, starting each new one on a new page, with a title and a running page count for each file.
The standard library provides a variety of functions, a few of which stand out as especially useful. We have already mentioned the string functions strlen, strcpy, strcat and strcmp. Here are some others.
The standard library provides a rather restricted version of the function ungetch which we wrote in Chapter 4; it is called ungetc.
The material in this chapter is concerned with the interface between C programs and the UNIXt operating system. Since most C users are on UNIX systems, this should be helpful to a majority of readers. Even if you use C on a different machine, however, you should be able to glean more insight into C programming from studying these examples.
The chapter is divided into three major areas: input/output, file system, and a storage allocator. The first two parts assume a modest familiarity with the external characteristics of UNIX. variety of operating systems. On any particular system the routines of the standard library have to be written in terms of the I/O facilities actually available on the host system. In the next few sections we will describe the basic system entry points for I/O on the UNIX operating system, and illustrate how parts of the standard library can be implemented with them.
In the UNIX operating system, all input and output is done by reading or writing files, because all peripheral devices, even the user’s terminal, are files in the file system. This means that a single, homogeneous interface handles all communication between a program and peripheral devices.
Since input and output involving the user’s terminal is so common, special arrangements exist to make this convenient. When the command interpreter (the “shell”) runs a program, it opens three files, with file descriptors 0, 1, and 2, called the standard input, the standard output, and the standard error output. All of these are normally connected to the terminal, so if a program reads file descriptor 0 and writes file descriptors 1 and 2, it can do terminal I/O without worrying about opening the files.
Each call returns a byte count which is the number of bytes actually transferred. On reading, the number of bytes returned may be less than the indicates an error of some sort. For writing, the returned value is the number of bytes actually written; it is generally an error if this isn’t equal to the number supposed to be written.
The number of bytes to be read or written is quite arbitrary. The two most common values are 1, which means one character at a time (“unbuffered”), and 512, which corresponds to a physical blocksize on many peripheral devices. This latter size will be most efficient, but even character at a time I/O is not inordinately expensive.
Putting these facts together, we can write a simple program to copy its input to its output, the equivalent of the file copying program written for input and output can be redirected to any file or device.
If the file size is not a multiple of BUFSIZE, some read will return a smaller number of bytes to be written by write; the next call to read after that will return zero.
It is instructive to see how read and write can be used to construct higher level routines like getchar, putchar, etc. For example, here is a version of getchar which does unbuffered input.
The second version of getchar does input in big chunks, and hands out the characters one at a time.
Other than the default standard input, output and error files, you must explicitly open files in order to read or write them. There are two system entry points for this, open and creat [sic].
As with fopen, the name argument is a character string corresponding to the external file name. The access mode argument is different, however: rwmode is 0 for read, 1 for write, and 2 for read and write access, open returns -1 if any error occurs; otherwise it returns a valid file descriptor.
It is an error to try to open a file that does not exist. The entry point creat is provided to create new files, or to re-write old ones.
There is a limit (typically 15-25) on the number of files which a program may have open simultaneously. Accordingly, any program which intends to process many files must be prepared to re-use file descriptors. The routine close breaks the connection between a file descriptor and an open file, and frees the file descriptor for use with some other file. Termination of a program via exit or return from the main program closes all open files.
Rewrite the program cat from Chapter 7 using read, write, open and close instead of their standard library equivalents. Perform experiments to determine the relative speeds of the two versions.
With lseek, it is possible to treat files more or less like large arrays, at the price of slower access. For example, the following simple function reads any number of bytes from any arbitrary place in a file.
Clearly, seek can be written in terms of lseek, and vice versa. Write each in terms of the other.
Let us illustrate how some of these pieces fit together by showing an implementation of the standard library routines fopen and getc.
Recall that files in the standard library are described by file pointers rather than file descriptors. A file pointer is a pointer to a structure that contains several pieces of information about the file: a pointer to a buffer, so the file can be read in large chunks; a count of the number of characters left in the buffer; a pointer to the next character position in the buffer; some flags describing read/ write mode, etc.; and the file descriptor.
The data structure that describes a file is contained in the file stdio . h, which must be included (by # include) in any source file that uses routines from the standard library. It is also included by functions in that library. In the following excerpt from stdio . h, names which are intended for use only by functions of the library begin with an underscore so they are less likely to collide with names in a user’s program.
The getc macro normally just decrements the count, advances the pointer, and returns the character. (A long #define is continued with a backslash.) If the count goes negative, however, getc calls the function _fillbuf to replenish the buffer, re-initialize the structure contents, and return a character. A function may present a portable interface, yet itself contain non-portable constructs: getc masks the character with 0377, which defeats the sign extension done by the PDP-11 and ensures that all characters will be positive.
Although we will not discuss any details, we have included the definition of putc to show that it operates in much the same way as getc, calling a function _f lushbuf when its buffer is full.
The function fopen can now be written. Most of fopen is concerned with getting the file opened and positioned at the right place, and setting the flag bits to indicate the proper state, fopen does not allocate any buffer space; this is done by _f illbuf when the file is first read.
The function _fillbuf is rather more complicated. The main complexity lies in the fact that _fillbuf attempts to permit access to the file even though there may not be enough memory to buffer the I/O. If space for a new buffer can be obtained from calloc, all is well; if not, _fillbuf does unbuffered I/O using a single character stored in a private array.
The first call to getc for a particular file finds a count of zero, which forces a call of _f illbuf. If _fillbuf finds that the file is not open for reading, it returns EOF immediately. Otherwise, it tries to allocate a large buffer, and, failing that, a single character buffer, setting the buffering information in _f lag appropriately.
Once the buffer is established, _fillbuf simply calls read to fill it, sets the count and pointers, and returns the character at the beginning of the buffer. Subsequent calls to _f illbuf will find a buffer allocated.
The initialization of the _f lag part of the structure shows that stdin is to be read, stdout is to be written, and stderr is to be written unbuffered.
A different kind of file system interaction is sometimes called for — determining information about a file, not what it contains. The UNIX command Is (“list directory”) is an example — it prints the names of files in a directory, and optionally, other information, such as sizes, permissions, and so on.
Since on UNIX at least a directory is just a file, there is nothing special about a command like Zs; it reads a file and picks out the relevant parts of the information it finds there. Nonetheless, the format of that information is determined by the system, not by a user program, so Is needs to know how the system represents things.
We will illustrate some of this by writing a program called /size. f. 'size is a special form of Is which prints the sizes of all files named in its argument list. If one of the files is a directory, j, 'size applies itself recursively to that directory. If there are no arguments at all, it processes the current directory.
The “type” ino_t is a typedef describing the index into the inode table. It happens to be unsigned on PDP-11 UNIX, but this is not the sort of information to embed in a program: it might be different on a different system. Hence the typedef. A complete set of “system” types is found in sys/ types .h.
Most of these are explained by the comment fields. The st_mode entry contains a set of flags describing the file; for convenience, the flag definitions are also part of the file sys/stat.h.
Now we are able to write the program f size . If the mode obtained from stat indicates that a file is not a directory, then the size is at hand and can be printed directly. If it is a directory, however, then we have to process that directory one file at a time; it in turn may contain sub-directories, so the process is recursive.
The main routine as usual deals primarily with command-line arguments; it hands each argument to the function f size in a big buffer.
The function fsize prints the size of the file. If the file is a directory, however, fsize first calls directory to handle all the files in it. Note the use of the flag names S_IFMT and S_IFDIR from stat .h.
The function directory is the most complicated. Much of it is concerned, however, with creating the full pathname of the file being dealt with.
Although the f. size program is rather specialized, it does indicate a couple of important ideas. First, many programs are not “system programs”; they merely use information whose form or content is maintained by the operating system. Second, for such programs, it is crucial that the representation of the information appear only in standard “header files” like stat.h and dir.h, and that programs include those files instead of embedding the actual declarations in themselves.
In Chapter 5, we presented a simple-minded version of alloc. The version which we will now write is unrestricted: calls to alloc and free may be intermixed in any order; alloc calls upon the operating system to obtain more memory as necessary. Besides being useful in their own right, these routines illustrate some of the considerations involved in writing machine-dependent code in a relatively machine-independent way, and also show a real-life application of structures, unions and typedef .
Rather than allocating from a compiled-in fixed-sized array, alloc will request space from the operating system as needed. Since other activities in the program may also request space asynchronously, the space alloc manages may not be contiguous. Thus its free storage is kept as a chain of free blocks. Each block contains a size, a pointer to the next block, and the space itself. The blocks are kept in order of increasing storage address, and the last block (highest address) points to the first, so the chain is actually a ring.
When a request is made, the free list is scanned until a big enough block is found. If the block is exactly the size requested it is unlinked from the list and returned to the user. If the block is too big, it is split, and the proper amount is returned to the user while the residue is put back on the free list. If no big enough block is found, another block is obtained from the operating system and linked into the free list; searching then resumes.
Freeing also causes a search of the free list, to find the proper place to insert the block being freed. If the block being freed is adjacent to a free list block on either side, it is coalesced with it into a single bigger block, so storage does not become too fragmented. Determining adjacency is easy because the free list is maintained in storage order.
One problem, which we alluded to in Chapter 5, is to ensure that the storage returned by alloc is aligned properly for the objects that will be stored in it. Although machines vary, for each machine there is a most restrictive type: if the most restricted type can be stored at a particular address, all other types may be also. For example, on the IBM 360/370, the Honeywell 6000, and many other machines, any object may be stored on a boundary appropriate for a double; on the PDP-11, int suffices.
In alloc, the requested size in characters is rounded up to the proper number of header-sized units; the actual block that will be allocated contains one more unit, for the header itself, and this is the value recorded in the size field of the header. The pointer returned by alloc points at the free space, not at the header itself.
The variable base is used to get started; if allocp is NULL, as it is at the first call of alloc, then a degenerate free list is created: it contains one block of size zero, and points to itself. In any case, the free list is then searched. The search for a free block of adequate size begins at the point (allocp) where the last block was found; this strategy helps keep the list homogeneous. If a too-big block is found, the tail end is returned to the user; in this way the header of the original needs only to have its size adjusted. In all cases, the pointer returned to the user is to the actual free area, which is one unit beyond the header. Notice that p is converted to a character pointer before being returned by alloc.
Although storage allocation is intrinsically machine dependent, the code shown above illustrates how the machine dependencies can be controlled and confined to a very small part of the program. The use of typedef and union handles alignment (given that sbrk supplies an appropriate pointer). Casts arrange that pointer conversions are made explicit, and even cope with a badly-designed system interface. Even though the details here are related to storage allocation, the general approach is applicable to other situations as well.
The standard library function calloc(n, size) returns a pointer to n objects of size size, with the storage initialized to zero. Write calloc, using alloc either as a model or as a function to be called.
Write a routine bfree(p, n) which will free an arbitrary block p of n characters into the free list maintained by alloc and free.
By using bfree, a user can add a static or external array to the free list at any time.
This manual describes the C language on the DEC PDP-11, the Honeywell 6000, the IBM System/370, and the Interdata 8/32. Where differences exist, it concentrates on the PDP-11, but tries, to point out implementation-dependent details. With few exceptions, these dependencies follow directly from the underlying properties of the hardware; the various compilers are generally quite compatible.
There are six classes of tokens: identifiers, keywords, constants, strings, operators, and other separators. Blanks, tabs, newlines, and comments (collectively, “white space”) as described below are ignored except as they serve to separate tokens. Some white space is required to separate otherwise adjacent identifiers, keywords, and constants.
If the input stream has been parsed into tokens up to a given character, the next token is taken to include the longest string of characters which could possibly constitute a token.
The characters /* introduce a comment, which terminates with the characters */. Comments do not nest.
The entry keyword is not currently implemented by any compiler but is reserved for future use. Some implementations also reserve the words fortran and asm.
There are several kinds of constants, as listed below. Hardware characteristics which affect sizes are summarized in §2.6.
An integer constant consisting of a sequence of digits is taken to be octal if it begins with 0 (digit zero), decimal otherwise. The digits 8 and 9 have octal value 10 and 11 respectively. A sequence of digits preceded by Ox or OX (digit zero) is taken to be a hexadecimal integer. The hexadecimal digits include a or A through f or F with values 10 through 15. A decimal constant whose value exceeds the largest signed machine integer is taken to be long; an octal or hex constant which exceeds the largest unsigned machine integer is likewise taken to be long.
A character constant is a character enclosed in single quotes, as in 'x'. The value of a character constant is the numerical value of the character in the machine’s character set.
The escape \ddd consists of the backslash followed by 1, 2, or 3 octal digits which are taken to specify the value of the desired character. A special case of this construction is \0 (not followed by a digit), which indicates the character NUL. If the character following a backslash is not one of those specified, the backslash is ignored.
A floating constant consists of an integer part, a decimal point, a fraction part, an e or E, and an optionally signed integer exponent. The integer and fraction parts both consist of a sequence of digits. Either the integer part or the fraction part (not both) may be missing; either the decimal point or the e and the exponent (not both) may be missing. Every floating constant is taken to be double-precision.
A string has type “array of characters” and storage class static (see §4 below) and is initialized with the given characters. All strings, even when written identically, are distinct. The compiler places a null byte \0 at the end of each string so that programs which scan the string can find its end. In a string, the double quote character " must be preceded by a \; in addition, the same escapes as described for character constants may be used. Finally, a \ and an immediately following newline are ignored.
The following table summarizes certain hardware properties which vary from machine to machine. Although these affect program portability, in practice they are less of a problem than might be thought a priori.
C bases the interpretation of an identifier upon two attributes of the identifier: its storage class and its type. The storage class determines the location and lifetime of the storage associated with an identifier; the type determines the meaning of the values found in the identifier’s storage.
There are four declarable storage classes: automatic, static, external, and register. Automatic variables are local to each invocation of a block (§9.2), and are discarded upon exit from the block; static variables are local to a block, but retain their values upon reentry to a block even after control has left the block; external variables exist and retain their values throughout the execution of the entire program, and may be used for communication between functions, even separately compiled functions. Register variables are (if possible) stored in the fast registers of the machine; like automatic variables they are local to each block and disappear on exit from the block.
Objects declared as characters (char) are large enough to store any member of the implementation’s character set, and if a genuine character from that character set is stored in a character variable, its value is equivalent to the integer code for that character. Other quantities may be stored into character variables, but the implementation is machine-dependent.
Single-precision floating point (float) and double-precision floating point (double) may be synonymous in some implementations.
Because objects of the foregoing types can usefully be interpreted as numbers, they will be referred to as arithmetic types. Types char and int of all sizes will collectively be called integral types, float and double will collectively be called floating types.
An object is a manipulatable region of storage; an lvalue is an expression referring to an object. An obvious example of an lvalue expression is an identifier. There are operators which yield lvalues: for example, if E is an expression of pointer type, then *E is an lvalue expression referring to the object to which E points. The name “lvalue” comes from the assignment expression El = E2 in which the left operand El must be an lvalue expression. The discussion of each operator below indicates whether it expects lvalue operands and whether it yields an lvalue.
A number of operators may, depending on their operands, cause conversion of the value of an operand from one type to another. This section explains the result to be expected from such conversions. §6.6 summarizes the conversions demanded by most ordinary operators; it will be supplemented as required by the discussion of each operator.
A character or a short integer may be used wherever an integer may be used. In all cases the value is converted to an integer. Conversion of a shorter integer to a longer always involves sign extension; integers are signed quantities. Whether or not sign-extension occurs for characters is machine dependent, but it is guaranteed that a member of the standard character set is non-negative. Of the machines treated by this manual, only the PDP-11 sign-extends. On the PDP-11, character variables range in value from —128 to 127; the characters of the ASCII alphabet are all positive. A character constant specified with an octal escape suffers sign extension and may appear negative; for example, ' \377 ' has the value -1 .
When a longer integer is converted to a shorter or to a char, it is truncated on the left; excess bits are simply discarded.
All floating arithmetic in C is carried out in double-precision; whenever a float appears in an expression it is lengthened to double by zero-padding its fraction. When a double must be converted to float, for example by an assignment, the double is rounded before truncation to float length.
Conversions of floating values to integral type tend to be rather machinedependent; in particular the direction of truncation of negative numbers varies from machine to machine. The result is undefined if the value will not fit in the space provided.
Conversions of integral values to floating type are well behaved. Some loss of precision occurs if the destination lacks sufficient bits.
An integer or long integer may be added to or subtracted from a pointer; in such a case the first is converted as specified in the discussion of the addition operator.
Two pointers to objects of the same type may be subtracted; in this case the result is converted to an integer as specified in the discussion of the subtraction operator.
Whenever an unsigned integer and a plain integer are combined, the plain integer is converted to unsigned and the result is unsigned. The value is the least unsigned integer congruent to the signed integer (modulo 2 wordsize ). In a 2’s complement representation, this conversion is conceptual and there is no actual change in the bit pattern.
When an unsigned integer is converted to long, the value of the result is the same numerically as that of the unsigned integer. Thus the conversion amounts to padding with zeros on the left.
First, any operands of type char or short are converted to int, and any of type float are converted to double.
Then, if either operand is double, the other is converted to double and that is the type of the result.
Otherwise, if either operand is long, the other is converted to long and that is the type of the result.
Otherwise, if either operand is unsigned, the other is converted to unsigned and that is the type of the result.
The precedence of expression operators is the same as the order of the major subsections of this section, highest precedence first. Thus, for example, the expressions referred to as the operands of + (§7.4) are those expressions defined in §§7.17.3. Within each subsection, the operators have the same precedence. Left- or right-associativity is specified in each subsection for the operators discussed therein. The precedence and associativity of all the expression operators is summarized in the grammar of §18.
Otherwise the order of evaluation of expressions is undefined. In particular the compiler considers itself free to compute subexpressions in the order it believes most efficient, even if the subexpressions involve side effects. The order in which side effects take place is unspecified. Expressions involving a commutative and associative operator (*, +, &, I, *) may be rearranged arbitrarily, even in the presence of parentheses; to force a particular order of evaluation an explicit temporary must be used.
The handling of overflow and divide check in expression evaluation is machine-dependent. All existing implementations of C ignore integer overflows; treatment of division by 0, and all floating-point exceptions, varies between machines, and is usually adjustable by a library function.
Primary expressions involving . , ->, subscripting, and function calls group left to right.
An identifier is a primary expression, provided it has been suitably declared as discussed below. Its type is specified by its declaration. If the type of the identifier is “array of ...”, however, then the value of the identifier-expression is a pointer to the first object in the array, and the type of the expression is “pointer to ...”. Moreover, an array identifier is not an lvalue expression. Likewise, an identifier which is declared “function returning ...”, when used except in the function-name position of a call, is converted to “pointer to function returning . .
A constant is a primary expression. Its type may be int, long, or double depending on its form. Character constants have type int; floating constants are double.
A parenthesized expression is a primary expression whose type and value are identical to those of the unadorned expression. The presence of parentheses does not affect whether the expression is an lvalue.
A function call is a primary expression followed by parentheses containing a possibly empty, comma-separated list of expressions which constitute the actual arguments to the function. The primary expression must be of type “function returning ...”, and the result of the function call is of type “...”. As indicated below, a hitherto unseen identifier followed immediately by a left parenthesis is contextually declared to represent a function returning an integer; thus in the most common case, integer-valued functions need not be declared.
Any actual arguments of type float are converted to double before the call; any of type char or short are converted to int; and as usual, array names are converted to pointers. No other conversions are performed automatically; in particular, the compiler does not compare the types of actual arguments with those of formal arguments. If conversion is needed, use a cast; see §7.2, 8.7.
In preparing for the call to a function, a copy is made of each actual parameter; thus, all argument-passing in C is strictly by value. A function may change the values of its formal parameters, but these changes cannot affect the values of the actual parameters. On the other hand, it is possible to pass a pointer on the understanding that the function may change the value of the object to which the pointer points. An array name is a pointer expression. The order of evaluation of arguments is undefined by the language; take note that the various compilers differ.
A primary expression followed by a dot followed by an identifier is an expression. The first expression must be an lvalue naming a structure or a union, and the identifier must name a member of the structure or union. The result is an lvalue referring to the named member of the structure or union.
A primary expression followed by an arrow (built from a - and a >) followed by an identifier is an expression. The first expression must be a pointer to a structure or a union and the identifier must name a member of that structure or union. The result is an lvalue referring to the named member of the structure or union to which the pointer expression points.
Thus the expression E1->MOS is the same as (*E1).MOS. Structures and unions are discussed in §8.5. The rules given here for the use of structures and unions are not enforced strictly, in order to allow an escape from the typing mechanism. See §14.1.
The unary * operator means indirection : the expression must be a pointer, and the result is an lvalue referring to the object to which the expression points. If the type of the expression is “pointer to . . .”, the type of the result is “...”.
The result of the unary & operator is a pointer to the object referred to by the lvalue. If the type of the lvalue is “...”, the type of the result is “pointer to . . .”.
The result of the unary - operator is the negative of its operand. The usual arithmetic conversions are performed. The negative of an unsigned quantity is computed by subtracting its value from 2", where n is the number of bits in an int. There is no unary + operator.
The result of the logical negation operator ! is 1 if the value of its operand is 0, 0 if the value of its operand is non-zero. The type of the result is int. It is applicable to any arithmetic type or to pointers.
The ~ operator yields the one’s complement of its operand. The usual arithmetic conversions are performed. The type of the operand must be integral.
The object referred to by the lvalue operand of prefix ++ is incremented. The value is the new value of the operand, but is not an lvalue. The expression ++x is equivalent to x+=1 . See the discussions of addition (§7.4) and assignment operators (§7.14) for information on conversions.
The lvalue operand of prefix — is decremented analogously to the prefix ++ operator.
When postfix ++ is applied to an lvalue the result is the value of the object referred to by the lvalue. After the result is noted, the object is incremented in the same manner as for the prefix ++ operator. The type of the result is the same as the type of the lvalue expression.
When postfix — is applied to an lvalue the. result is the value of the object referred to by the lvalue. After the result is noted, the object is decremented in the manner as for the prefix — operator. The type of the result is the same as the type of the lvalue expression.
An expression preceded by the parenthesized name of a data type causes conversion of the value of the expression to the named type. This construction is called a cast . Type names are described in §8.7.
The sizeof operator yields the size, in bytes, of its operand. (A byte is undefined by the language except in terms of the value of sizeof. However, in all existing implementations a byte is the space required to hold a char.) When applied to an array, the result is the total number of bytes in the array. The size is determined from the declarations of the objects in the expression. This expression is semantically an integer constant and may be used anywhere a constant is required. Its major use is in communication with routines like storage allocators and I/O systems.
The sizeof operator may also be applied to a parenthesized type name. In that case it yields the size, in bytes, of an object of the indicated type.
The construction sizeof {type ) is taken to be a unit, so the expression sizeof {type) -2 is the same as (sizeof ( type ) )-2.
The multiplicative operators *, /, and % group left-to-right. The usual arithmetic conversions are performed.
The binary * operator indicates multiplication. The * operator is associative and expressions with several multiplications at the same level may be rearranged by the compiler.
The binary / operator indicates division. When positive integers are divided truncation is toward 0, but the form of truncation is machine-dependent if either operand is negative. On all machines covered by this manual, the remainder has the same sign as the dividend. It is always true that (a/b) *b + a%b is equal to a (if b is not 0).
The binary % operator yields the remainder from the division of the first expression by the second. The usual arithmetic conversions are performed. The operands must not be float.
The additive operators + and - group left-to-right. The usual arithmetic conversions are performed. There are some additional type possibilities for each operator.
The result of the + operator is the sum of the operands. A pointer to an object in an array and a value of any integral type may be added. The latter is in all cases converted to an address offset by multiplying it by the length of the object to which the pointer points. The result is a pointer of the same type as the original pointer, and which points to another object in the same array, appropriately offset from the original object. Thus if P is a pointer to an object in an array, the expression P+1 is a pointer to the next object in the array.
The + operator is associative and expressions with several additions at the same level may be rearranged by the compiler.
The result of the - operator is the difference of the operands. The usual arithmetic conversions are performed. Additionally, a value of any integral type may be subtracted from a pointer, and then the same conversions as for addition apply.
If two pointers to objects of the same type are subtracted, the result is converted (by division by the length of the object) to an int representing the number of objects separating the pointed-to objects. This conversion will in general give unexpected results unless the pointers point to objects in the same array, since pointers, even to objects of the same type, do not necessarily differ by a multiple of the object-length.
The shift operators « and » group left-to-right. Both perform the usual arithmetic conversions on their operands, each of which must be integral. Then the right operand is converted to int; the type of the result is that of the left operand. The result is undefined if the right operand is negative, or greater than or equal to the length of the object in bits.
The value of El «E2 is El (interpreted as a bit pattern) left-shifted E2 bits; vacated bits are 0-filled. The value of El »E2 is El right-shifted E2 bit positions. The right shift is guaranteed to be logical (0-fill) if El is unsigned; otherwise it may be (and is, on the PDP-11) arithmetic (fill by a copy of the sign bit).
The relational operators group left-to-right, but this fact is not very useful; a<b<c does not mean what it seems to.
The operators < (less than), > (greater than), <= (less than or equal to) and >= (greater than or equal to) all yield 0 if the specified relation is false and 1 if it is true. The type of the result is int. The usual arithmetic conversions are performed. Two pointers may be compared; the result depends on the relative locations in the address space of the pointed-to objects. Pointer comparison is portable only when the pointers point to objects in the same array.
The == (equal to) and the ! = (not equal to) operators are exactly analogous to the whenever a<b and c<d have the same truth-value).
A pointer may be compared to an integer, but the result is machine dependent unless the integer is the constant 0. A pointer to which 0 has been assigned is guaranteed not to point to any object, and will appear to be equal to 0; in conventional usage, such a pointer is considered to be null.
The & operator is associative and expressions involving & may be rearranged. The usual arithmetic conversions are performed; the result is the bitwise AND function of the operands. The operator applies only to integral operands.
The * operator is associative and expressions involving * may be rearranged. The usual arithmetic conversions are performed; the result is the bitwise exclusive OR function of the operands. The operator applies only to integral operands.
The I operator is associative and expressions involving l may be rearranged. The usual arithmetic conversions are performed; the result is the bitwise inclusive OR function of its operands. The operator applies only to integral operands.
The && operator groups left-to-right. It returns 1 if both its operands are non-zero, 0 otherwise. Unlike &, && guarantees left-to-right evaluation; moreover the second operand is not evaluated if the first operand is 0.
The operands need not have the same type, but each must have one of the fundamental types or be a pointer. The result is always int .
The I I operator groups left-to-right. It returns 1 if either of its operands is nonzero, and 0 otherwise. Unlike I , II guarantees left-to-right evaluation; moreover, the second operand is not evaluated if the value of the first operand is non-zero.
The operands need not have the same type, but each must have one of the fundamental types or be a pointer. The result is always int.
Conditional expressions group right-to-left. The first expression is evaluated and if it is non-zero, the result is the value of the second expression, otherwise that of third expression. If possible, the usual arithmetic conversions are performed to bring the second and third expressions to a common type; otherwise, if both are pointers of the same type, 1 the result has the common type; otherwise, one must be a pointer and the other the constant 0, and the result has the type of the pointer. Only one of the second and third expressions is evaluated.
There are a number of assignment operators, all of which group right-to-left. All require an lvalue as their left operand, and the type of an assignment expression is that of its left operand. The value is the value stored in the left operand after the assignment has taken place. The two parts of a compound assignment operator are separate tokens.
In the simple assignment with =, the value of the expression replaces that of the object referred to by the lvalue. If both operands have arithmetic type, the right operand is converted to the type of the left preparatory to the assignment.
The compilers currently allow a pointer to be assigned to an integer, an integer to a pointer, and a pointer to a pointer of another type. The assignment is a pure copy operation, with no conversion. This usage is nonportable, and may produce pointers which cause addressing exceptions when used. However, it is guaranteed that assignment of the constant 0 to a pointer will produce a null pointer distinguishable from a pointer to any object.
The declarators in the declarator-list contain the identifiers being declared. The decl-specifiers consist of a sequence of type and storage class specifiers.
The auto, static, and register declarations also serve as definitions in that they cause an appropriate amount of storage to be reserved. In the extern case there must be an external definition (§10) for the given identifiers somewhere outside the function in which they are declared.
A register declaration is best thought of as an auto declaration, together with a hint to the compiler that the variables declared will be heavily used. Only the first few such declarations are effective. Moreover, only variables of certain types will be stored in registers; on the PDP-11, they are int, char, or pointer. One other restriction applies to register variables: the address-of operator & cannot be applied to them. Smaller, faster programs can be expected if register declarations are used appropriately, but future improvements in code generation may render them unnecessary.
At most one sc-specifier may be given in a declaration. If the sc-specifier is missing from a declaration, it is taken to be auto inside a function, extern outside. Exception: functions are never automatic.
The words long, short, and unsigned may be thought of as adjectives; the following combinations are acceptable.
The meaning of the last is the same as double. Otherwise, at most one typespecifier may be given in a declaration. If the type-specifier is missing from a declaration, it is taken to be int.
Specifiers for structures and unions are discussed in §8.5; declarations with typedef names are discussed in §8.8.
The declarator-list appearing in a declaration is a comma-separated sequence of declarators, each of which may have an initializer.
